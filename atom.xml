<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title></title>
	<link href="https://ryanisaacg.com/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://ryanisaacg.com"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-06-05T00:00:00+00:00</updated>
	<id>https://ryanisaacg.com/atom.xml</id>
	<entry xml:lang="en">
		<title>Rewriting Fellowship&#x27;s &#x27;Get Away&#x27;</title>
		<published>2022-06-05T00:00:00+00:00</published>
		<updated>2022-06-05T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/tabletop/fellowship-getaway/" type="text/html"/>
		<id>https://ryanisaacg.com/tabletop/fellowship-getaway/</id>
		<content type="html">&lt;p&gt;This year I&#x27;ve been playing &lt;a href=&quot;https:&#x2F;&#x2F;liberigothica.itch.io&#x2F;fellowship-a-tabletop-adventure-game&quot;&gt;Fellowship 2e&lt;&#x2F;a&gt;, a fantasy adventure RPG that&#x27;s &lt;a href=&quot;http:&#x2F;&#x2F;apocalypse-world.com&#x2F;&quot;&gt;Powered by the Apocalypse&lt;&#x2F;a&gt;, and I have a few gripes with an otherwise great game. Since session 1, I&#x27;ve felt like the core move Get Away needs re-writing, and I decided to take a stab at it.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;&lt;em&gt;The contents of this post are licensed under &lt;a href=&quot;https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-sa&#x2F;2.0&#x2F;&quot;&gt;CC-BY-SA&lt;&#x2F;a&gt;. The excerpt from Fellowship is used under the same license.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The relevant move:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;When you need to get somewhere out of reach or out of sight, tell us where you&#x27;re going and roll +Grace. If you have the Clumsy tag, you take -1 to Get Away. On a 10+, choose two. On a 7-9, choose one:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;You get there quickly, avoiding any harm along the way.&lt;&#x2F;li&gt;
&lt;li&gt;You get there quietly, drawing no attention.&lt;&#x2F;li&gt;
&lt;li&gt;You grab someone nearby and bring them along with you.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Two things bother me. First, I think &amp;quot;You grab someone nearby and bring them along with you&amp;quot; has only been picked a handful of times in ten sessions of play at my table. It&#x27;s just not very useful in most situations. The other is the move&#x27;s use of &amp;quot;negative choices&amp;quot;; the player is choosing things that &lt;em&gt;don&#x27;t&lt;&#x2F;em&gt; happen, rather than things that &lt;em&gt;do.&lt;&#x2F;em&gt; This can put the GM in an awkward situation: if you &lt;em&gt;don&#x27;t&lt;&#x2F;em&gt; choose &amp;quot;drawing no attention&amp;quot;, does that necessarily mean you &lt;em&gt;do&lt;&#x2F;em&gt; draw attention? Does it depend on the situation?&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, I read &lt;a href=&quot;https:&#x2F;&#x2F;forums.gauntlet-rpg.com&#x2F;t&#x2F;negative-pick-lists&#x2F;1867&#x2F;2&quot;&gt;a Gauntlet post&lt;&#x2F;a&gt; by Jeremy Strandberg, author of the upcoming &lt;a href=&quot;https:&#x2F;&#x2F;stonetop.backerkit.com&#x2F;hosted_preorders&#x2F;&quot;&gt;Stonetop&lt;&#x2F;a&gt;, a little while ago:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;So if you’re going to use moves that have you chose “avoid negative” options, you kind of have to assume that some players&#x2F;GMs will take it one way, and others will take it another, and ask yourself if you’re okay with either interpretation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Or&lt;&#x2F;em&gt; you can make it clear via the move’s text which you intend. A few ways to do that. You can set the default in the “body” of the move and then let choices counter&#x2F;add to the default. I think this works well for moves that mix and match “positive” and “avoid negative” choices.&lt;&#x2F;p&gt;
&lt;p&gt;[...]&lt;&#x2F;p&gt;
&lt;p&gt;Personally, I &lt;em&gt;generally&lt;&#x2F;em&gt; try to avoid moves with “__ doesn’t happen” choices. I find that moves are cleaner and easier to understand when the choices are “positive” (as in: pick things that do happen, good or bad) rather than “negative” (as in: picking things that &lt;em&gt;don’t&lt;&#x2F;em&gt; happen).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;With that in mind, I thought about the move. It&#x27;s not hard to imagine this being a &amp;quot;positive&amp;quot; list (as in &#x27;pick things that happen&#x27;, not &#x27;things that are positive&#x27;), at least for the first two options. The third is a little harder, but I think with a little tweaking it could work. Here&#x27;s what I&#x27;m running now:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;When you need to get somewhere out of reach or out of sight, tell us where you&#x27;re going and roll +Grace. If you have the Clumsy tag, you take -1 to Get Away. On any hit, you get where you&#x27;re going; on a 7-9, choose one:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;You take a treacherous route, and take damage along the way&lt;&#x2F;li&gt;
&lt;li&gt;You leave yourself open to being spotted or trailed&lt;&#x2F;li&gt;
&lt;li&gt;You leave subtly or suddenly, with your allies behind and none the wiser. You cannot choose this option while working alone&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;I see a few advantages. Importantly, this move is just friendlier to players. Often something that requires a character Get Away can also be Overcome (Fellowship&#x27;s catch-all move for avoiding harm). Overcome&#x27;s 10+ condition leaves the character perfectly fine; why not the same for Get Away? The new move also makes the outcome clear: on a 7-9, the player chooses something bad that happens, rather than taking one possible option off the table. You can either be damaged, followed, or abandon your allies. I chose to make the last option sting a little more, and also close off its use in solo scenarios.&lt;&#x2F;p&gt;
&lt;p&gt;This isn&#x27;t the only tweak I&#x27;ve made to Fellowship, and I may have more to say about my ongoing game and the hacks I&#x27;ve made later. For now, if you use this in your own game, &lt;a href=&quot;mailto:ryan@ryanisaacg.com&quot;&gt;let me know&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Falling in love with git bisect</title>
		<published>2022-05-29T00:00:00+00:00</published>
		<updated>2022-05-29T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/git-bisect/" type="text/html"/>
		<id>https://ryanisaacg.com/code/git-bisect/</id>
		<content type="html">&lt;p&gt;Recently I found myself tracking down a handful of regressions: bugs I knew hadn&#x27;t existed just a week or two before. I vaguely knew that there was a git command that could help me, but I had never really put it to serious use. Now that I have used it, I find myself falling in love with &lt;code&gt;git bisect&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;&lt;code&gt;bisect&lt;&#x2F;code&gt;, in the style of all things git, is slightly arcane and clunky but powerful nonetheless. All you have to do is tell git a known-good commit and a known-bad commit, and it will guide you through an efficient exploration of your repository&#x27;s history. At each step of the process, &lt;code&gt;bisect&lt;&#x2F;code&gt; presents you with a commit and asks &amp;quot;is this commit good, or bad?&amp;quot; A quick test of your system and you can produce the answer (failing tests, incorrect behavior, broken build, what have you) and inform git; it can then continue with a binary search to find the offending change.&lt;&#x2F;p&gt;
&lt;aside&gt;
&lt;p&gt;In case your runtime analysis skills are a little dusty, a binary search has an &lt;code&gt;O(log N)&lt;&#x2F;code&gt; runtime to find its result. Even with 10,000 commits between your good and bad state, at most you&#x27;ll have to inspect 13 to find the culprit.&lt;&#x2F;p&gt;
&lt;&#x2F;aside&gt;
&lt;p&gt;You can initiate bisect with&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;git bisect start&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;At any time, you can bail out of this operation with&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;git bisect reset&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;which is good to keep in mind if you find yourself tangled. Now that you&#x27;ve started the bisect, define the bounds by picking a commit that has &amp;quot;good&amp;quot; state and a commit that has &amp;quot;bad&amp;quot; state:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;git bisect good my-good-commit&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;and&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;git bisect bad my-bad-commit&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;aside&gt;
&lt;p&gt;Git has introduced new aliases for &lt;code&gt;good&lt;&#x2F;code&gt; and &lt;code&gt;bad&lt;&#x2F;code&gt;: &lt;code&gt;new&lt;&#x2F;code&gt; and &lt;code&gt;old&lt;&#x2F;code&gt;, to allow for value-neutral bisects (like tracking down a performance improvement). I find &lt;code&gt;good&lt;&#x2F;code&gt; and &lt;code&gt;bad&lt;&#x2F;code&gt; to be much stronger pnuemonics, so I use them, but it&#x27;s good to know about the other options.&lt;&#x2F;p&gt;
&lt;&#x2F;aside&gt;
&lt;p&gt;After you&#x27;ve specified your commits, git will check out the midpoint and ask you to evaluate it. Do whatever you need (run tests, inspect an app, check benchmarks) and then inform git that this commit is &lt;code&gt;good&lt;&#x2F;code&gt; or &lt;code&gt;bad&lt;&#x2F;code&gt; with a simple &lt;code&gt;git bisect good&#x2F;bad&lt;&#x2F;code&gt; as desired. The process will repeat a few times until you find what you&#x27;re looking for!&lt;&#x2F;p&gt;
&lt;p&gt;This is where we come to a crucial caveat: your git history. I find that it&#x27;s best to squash intermediary commits when merging, resulting in a clean list of working commits. It aids in history explorations like this one, and means you don&#x27;t have to fight through a flurry of &amp;quot;wip: temp&amp;quot; and &amp;quot;fix lint&amp;quot; garbage commits. However, if you find yourself confronted with a commit that you cannot test, &lt;code&gt;git bisect skip&lt;&#x2F;code&gt; is your friend.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;d like to learn more, the &lt;a href=&quot;https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-bisect&quot;&gt;git bisect docs&lt;&#x2F;a&gt; have more detail and even explore the topic of automatic bisecting. Happy hacking!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Game Every Month</title>
		<published>2021-06-10T00:00:00+00:00</published>
		<updated>2021-06-10T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/tabletop/game-a-month/" type="text/html"/>
		<id>https://ryanisaacg.com/tabletop/game-a-month/</id>
		<content type="html">&lt;p&gt;For the past couple years I&#x27;ve been playing around with tabletop RPG design. My goal was to make a comprehensive hack of a game like &lt;a href=&quot;https:&#x2F;&#x2F;bladesinthedark.com&#x2F;greetings-scoundrel&quot;&gt;&lt;em&gt;Blades in the Dark&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;rowanrookanddecard.com&#x2F;product&#x2F;spire-rpg&#x2F;&quot;&gt;&lt;em&gt;Spire: The City Must Fall&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;,
but none of my attempts panned out. I found myself caught in a rut of moving from big project to big project as they collapsed under their own weight. To break the cycle, I set myself a challenge: make an RPG (or at least &lt;em&gt;something&lt;&#x2F;em&gt; RPG-related) every month of 2021.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;the-games&quot;&gt;The Games&lt;&#x2F;h2&gt;
&lt;p&gt;I set myself this goal too late into January to really get anything out there, so we start our journey in February.&lt;&#x2F;p&gt;
&lt;div class=&quot;cover&quot;&gt;&lt;a href=&quot;&#x2F;games&#x2F;wrong-side-of-infinity&quot;&gt;&lt;img src=&quot;&#x2F;wrong-side-of-infinity.png&quot; alt=&quot;The cover for The Wrong Side of Infinity&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;
&lt;h3 id=&quot;february-the-wrong-side-of-infinity&quot;&gt;February: The Wrong Side of Infinity&lt;&#x2F;h3&gt;
&lt;p&gt;I started small and wrote a second draft of my one-page game &amp;quot;&lt;a href=&quot;https:&#x2F;&#x2F;mechanical-worlds.itch.io&#x2F;on-the-wrong-side-of-infinity&quot;&gt;The Wrong Side of Infinity&lt;&#x2F;a&gt;&amp;quot; (as well as giving its layout a new coat of paint). It wasn&#x27;t even a new game, but at least it&#x27;s something! This was way outside of my comfort zone; rather than piecing together parts of big indie games, I was trying to get at something pretty specific that I was feeling at the time.&lt;&#x2F;p&gt;
&lt;p&gt;This also happens to be my only Google-able game title (excluding search engine tricks like appending &amp;quot;RPG&amp;quot; to your search query). Search engine lesson for the future, I guess!&lt;&#x2F;p&gt;
&lt;div class=&quot;cover&quot;&gt;&lt;a href=&quot;&#x2F;games&#x2F;battle-of-the-band&quot;&gt;&lt;img src=&quot;&#x2F;battle-of-the-band.png&quot; alt=&quot;The cover for Battle of the Band&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;
&lt;h3 id=&quot;march-battle-of-the-band&quot;&gt;March: Battle of the Band&lt;&#x2F;h3&gt;
&lt;p&gt;March saw a hack of &lt;a href=&quot;http:&#x2F;&#x2F;www.onesevendesign.com&#x2F;laserfeelings&#x2F;&quot;&gt;&lt;em&gt;Lasers and Feelings&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; called &amp;quot;&lt;a href=&quot;https:&#x2F;&#x2F;mechanical-worlds.itch.io&#x2F;battle-of-the-band&quot;&gt;Battle of the Band&lt;&#x2F;a&gt;&amp;quot;. I had the idea for a music game where you roll over or under a target depending on what &amp;quot;key you&#x27;re using&amp;quot; (I&#x27;m not very far in my learning-music journey but I&#x27;m aware that this is mostly nonsense). Then I realized that there&#x27;s already a nice, simple framework for a game with roll over and roll under. Even though it&#x27;s one of many, many L&amp;amp;F hacks it was nice to get something out there.&lt;&#x2F;p&gt;
&lt;div class=&quot;cover&quot;&gt;&lt;a href=&quot;&#x2F;games&#x2F;exquisite-copse&quot;&gt;&lt;img src=&quot;&#x2F;exquisite-copse.png&quot; alt=&quot;The cover for Exquisite Copse&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;
&lt;h3 id=&quot;april-exquisite-copse&quot;&gt;April: Exquisite Copse&lt;&#x2F;h3&gt;
&lt;p&gt;My game for April was &amp;quot;&lt;a href=&quot;https:&#x2F;&#x2F;mechanical-worlds.itch.io&#x2F;exquisite-copse&quot;&gt;Exquisite Copse&lt;&#x2F;a&gt;&amp;quot;, which ended up being my entry to &lt;a href=&quot;https:&#x2F;&#x2F;itch.io&#x2F;jam&#x2F;wish-you-were-here&quot;&gt;Wish You Were Here: A Postcard Jam&lt;&#x2F;a&gt;. It&#x27;s a letter-writing game in the style of &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exquisite_corpse&quot;&gt;Exquisite Corpse&lt;&#x2F;a&gt;: each person contributes to the whole, while only seeing the previous contribution, and then hopefully something interesting comes out at the end. (If you&#x27;re curious, the pun came &lt;em&gt;before&lt;&#x2F;em&gt; the game. Once I had thought of the pun I knew I had to make it into a game, somehow).&lt;&#x2F;p&gt;
&lt;p&gt;The first draft was using a card prompt mechanic like &lt;a href=&quot;https:&#x2F;&#x2F;buriedwithoutceremony.com&#x2F;the-quiet-year&quot;&gt;&lt;em&gt;The Quiet Year&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;www.evilhat.com&#x2F;home&#x2F;for-the-queen&#x2F;&quot;&gt;&lt;em&gt;For the Queen&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. I dropped this because it was too many prompts for me to write in a month. My second draft, using a d66 table instead of a deck of cards, had the same problem. Additionally I couldn&#x27;t decide how many prompts the players should answer; I wanted the game to be fast enough that you could conceivably play it at a party. In the end I settled on three D6 tables to produce a prompt: hopefully enough to spark the imagination while still comfortably fitting on a postcard.&lt;&#x2F;p&gt;
&lt;div class=&quot;cover&quot;&gt;&lt;a href=&quot;&#x2F;games&#x2F;a-hole-in-the-mirror&quot;&gt;&lt;img src=&quot;&#x2F;a-hole-in-the-mirror.png&quot; alt=&quot;The cover for A Hole in the Mirror&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;
&lt;h3 id=&quot;may-a-hole-in-the-mirror&quot;&gt;May: A Hole in the Mirror&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;itch.io&#x2F;jam&#x2F;mock-cover-jam&quot;&gt;Mock Cover Jam&lt;&#x2F;a&gt; caught my attention, so I grabbed a premade cover and &lt;a href=&quot;https:&#x2F;&#x2F;mechanical-worlds.itch.io&#x2F;a-hole-in-the-mirror&quot;&gt;&lt;em&gt;A Hole in the Mirror&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; became my May game. This was interesting, because like April&#x27;s game I had to start with a title and work backwards towards the game, but &lt;em&gt;unlike&lt;&#x2F;em&gt; April&#x27;s game I had a lot of leeway in where to go. I couldn&#x27;t decide whether the title should be thematic (where a mirror is a stand-in for self-image) or literal (where a mirror is sort of a portal between worlds).&lt;&#x2F;p&gt;
&lt;p&gt;The thematic approach made me think of &lt;a href=&quot;https:&#x2F;&#x2F;magpiegames.com&#x2F;masks&#x2F;&quot;&gt;&lt;em&gt;Masks: A New Generation&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, a game about teenage superheroes and their self-image. In the game, conditions aren&#x27;t physical injuries but are instead negative emotions like Afraid or Angry. Your character can &#x27;clear&#x27; the condition by leaning into dramatic teenage behavior, like lashing out or running away. At the start of this project I thought about combining this mechanic with the push-and-pull of the No Dice No Masters token economy, where players would be encouraged to make bad decisions to enable their future successes.&lt;&#x2F;p&gt;
&lt;p&gt;As I picked at the core idea, I realized it reminded me more and more of the &lt;a href=&quot;https:&#x2F;&#x2F;rowanrookanddecard.com&#x2F;product&#x2F;the-resistance-toolbox&#x2F;&quot;&gt;Resistance system&lt;&#x2F;a&gt;, which powers &lt;a href=&quot;https:&#x2F;&#x2F;rowanrookanddecard.com&#x2F;product&#x2F;spire-rpg&#x2F;&quot;&gt;&lt;em&gt;Spire: The City Must Fall&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;rowanrookanddecard.com&#x2F;product&#x2F;heart-the-city-beneath-rpg&#x2F;&quot;&gt;&lt;em&gt;Heart: The City Beneath&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. Specifically I thought of &lt;a href=&quot;https:&#x2F;&#x2F;gshowitt.itch.io&#x2F;sepulchre&quot;&gt;Sepulchre&lt;&#x2F;a&gt;, Grant Howitt&#x27;s one-page stripdown of &lt;em&gt;Spire&lt;&#x2F;em&gt;. It takes Fallout (the mechanic for setbacks and injuries) and turns it from a random event to a player choice. There&#x27;s a kind of mechanical parallel between choosing to take Fallout and making a Weak Move in &lt;a href=&quot;https:&#x2F;&#x2F;buriedwithoutceremony.com&#x2F;dream-askew&quot;&gt;&lt;em&gt;Dream Askew&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. I made one other major deviation from most other Resistance games: removing the &amp;quot;damage dice&amp;quot; you roll on a success or failure, to determine how much stress you take or deal. Personally, it feels bad to roll a success then roll a 1 for my progress. Instead you roll a simple D6 pool to determine both how much progress you made and how much stress you incured while doing it.&lt;&#x2F;p&gt;
&lt;p&gt;If I had more time, I would have expanded a lot more on the types of player characters and the world around them. A short chapter on setting was cut entirely, leaving just the barebones pitch: the players are fae from a mirror dimension crossing over into ours to commit crimes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;takeaway&quot;&gt;Takeaway&lt;&#x2F;h2&gt;
&lt;p&gt;Just going through the process of making little things that I can complete in a month has been great for my creative process. It&#x27;s also helped me embrace simpler, smaller games than I had been trying before. (I think my fondness for D6 is pretty clear, though I can see card-based or diceless games in my future).&lt;&#x2F;p&gt;
&lt;p&gt;The flipside, however, is that I can&#x27;t keep at it! Making a game every month is a lot of work. I started out strong and jumped into each new game with zeal, but by May I found myself working more out of a sense of obligation than joy. After I released &lt;em&gt;A Hole in the Mirror&lt;&#x2F;em&gt;, I decided to pump the brakes. &amp;quot;Make a game every month&amp;quot; became an experiment for the spring, instead of a year-long goal.&lt;&#x2F;p&gt;
&lt;p&gt;Even if I could keep going, I want to be able to take a bit more time with my work. Most of these games are lightly proofread and barely playtested, if at all. None have any art to speak of, and the only layout is my own fumbling with Affinity Publisher. Without the self-imposed pressure of the month&#x27;s deadline to throw something up online, hopefully I can strike a balance between never shipping and putting out unfinished work. For example, I do think that the core mechanic behind &lt;em&gt;A Hole in the Mirror&lt;&#x2F;em&gt; has legs, and could maybe support a much larger and more intricate game. We&#x27;ll see!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;going-forward&quot;&gt;Going Forward&lt;&#x2F;h2&gt;
&lt;p&gt;To be honest, the original reason I stood up this blog was to talk about this project. But now that I&#x27;m here, I&#x27;m really liking the idea of putting up game design thoughts on a regular basis. Probably at some point I&#x27;ll set up a Twitter because that&#x27;s where the people are, but I like having my own little place to put things.&lt;&#x2F;p&gt;
&lt;p&gt;See you soon, hopefully, with progress updates on a slower project!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Dark Mode!</title>
		<published>2021-04-04T00:00:00+00:00</published>
		<updated>2021-04-04T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/dark-mode/" type="text/html"/>
		<id>https://ryanisaacg.com/code/dark-mode/</id>
		<content type="html">&lt;p&gt;If your browser is set to dark mode by default, you&#x27;ve probably noticed the site looks different! I now have some dark mode CSS, so this blog isn&#x27;t eye-searingly white if everything else is dark on your screen.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Under the hood I&#x27;m using a neat CSS feature called &lt;a href=&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;CSS&#x2F;Using_CSS_custom_properties&quot;&gt;CSS variables&lt;&#x2F;a&gt; to switch the colors.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately this means old posts with syntax highlighting have lost syntax highlighting, because setting up theme-specific highlights looked a little annoying. That&#x27;s not really a big deal to me, but I might fix it eventually.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Quicksilver and Open Source</title>
		<published>2020-10-13T00:00:00+00:00</published>
		<updated>2020-10-13T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/quicksilver-goodbye/" type="text/html"/>
		<id>https://ryanisaacg.com/code/quicksilver-goodbye/</id>
		<content type="html">&lt;p&gt;So this is a post that&#x27;s been bouncing around my head for a while, in one form or another. I created and maintain &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ryanisaacg&#x2F;quicksilver&quot;&gt;Quicksilver&lt;&#x2F;a&gt;, a 2D game framework for creating games for desktop and the web. The reason I&#x27;m writing this post is that I also haven&#x27;t &lt;em&gt;used&lt;&#x2F;em&gt; Quicksilver to make anything for over a year.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;TL;DR: Quicksilver has been a source of great joy and frustration for me, and was my first real experience with open source. I&#x27;m still committed to maintaining it, but I don&#x27;t think I&#x27;ll be actively improving or working on it going forward.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-project-s-beginning&quot;&gt;The Project&#x27;s Beginning&lt;&#x2F;h2&gt;
&lt;aside&gt;
&lt;p&gt;What follows is a quick history of Quicksilver, and why I wanted to make it. I&#x27;ve never written it all down in one place before, and I figured now was a good opportunity. If you just want the details on what&#x27;s next, feel free to &lt;a href=&quot;https:&#x2F;&#x2F;ryanisaacg.com&#x2F;code&#x2F;quicksilver-goodbye&#x2F;#so-long&quot;&gt;skip this section.&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;aside&gt;
&lt;p&gt;From the start of my game-making hobby, I wanted a few things: to make small games, to be able to run them on low-powered hardware, and to be able to share them on the web. This was the beginning of my troubles.&lt;&#x2F;p&gt;
&lt;p&gt;First I tried game engines, like GameMaker (which was actually my first programming environment), Unity, and later Godot. A few things about them frustrated me: the closed-source nature of Unity, Godot&#x27;s idiosyncratic custom scripting language (I understand this has improved), and being forced to lay my code out the way the engine wanted it. Ideally I would write the core of the gameplay code however I liked, and then add hooks to use for the engine tools. The paradigm of a game engine (a tool designed for teams, not soloists) wanted the opposite: everything should flow from the engine itself. To each their own, I guess.&lt;&#x2F;p&gt;
&lt;p&gt;Game frameworks fared better, but inevitably something bothered me enough to switch. When I was using LibGDX and Java, distributing the Java binaries was a struggle. When I was using MonoGame and C#, cross-platform development on Linux was painful. Any dynamically typed programming language would eventually push me away after hours wasted tracking down a trivial bug. Even when I found a satisfactory programming language, often the game development ecosystem was sorely lacking (this is what drove me from D). And after all that, most game frameworks didn&#x27;t support sharing my game on the web.&lt;&#x2F;p&gt;
&lt;p&gt;I tried developing for the web directly, rather than relying on translation layers or compilation steps. I made a few little things, but I never really could commit. This was before I was a web programmer by trade, so I spent a lot of time confused and annoyed. In the five or so years since Javascript has become a joy to use, as long as you&#x27;re willing to put up with byzantine build tools. Without these niceties I found it to be a pain; modularity didn&#x27;t exist (just link the script files into your HTML), odd typing decisions constantly bit me (did you know that the Canvas 2D API treats NaN as 0 when drawing?), and I missed something about having a native executable build I could email someone, and run with a single click.&lt;&#x2F;p&gt;
&lt;p&gt;In mid-2017, Rust was where I finally settled, because it gave me two things: easy native-executable distribution, and a web compilation option. At the time, web compilation was unstable and no-one was really using it to make games; people who did tended to write bindings to the webpage by hand. Pulling in the venerable &lt;code&gt;glutin&lt;&#x2F;code&gt; library for windowing on the desktop, I hand-wrote the Quicksilver-to-JS bindings for WebAssembly and got busy developing. It was buggy, it was a pain in the ass to use, and it was an absolute delight. Finally, native code running in the browser! I published my new library in the beginning of 2018, and slowly other people started to use it in their own work.&lt;&#x2F;p&gt;
&lt;p&gt;Maintaining the JS bindings by hand was an absolute disaster. In June of 2018, I worked up the energy to switch to a library to handle the browser interactions for me. This was well before the &lt;code&gt;web-sys&lt;&#x2F;code&gt; project, a comprehensive set of bindings to every browser API imaginable. When I was looking, I had two options. &lt;code&gt;stdweb&lt;&#x2F;code&gt;, an ambitious project with plans to bind every single browser API to an idiomatic Rust wrapper, and &lt;code&gt;wasm-bindgen&lt;&#x2F;code&gt;, a more efficient option with more maintainers, that required you to write the bindings yourself. I picked &lt;code&gt;stdweb&lt;&#x2F;code&gt; for its ergonomics (much to my future dismay) and continued on, now with a much-improved workflow and a great deal more stability.&lt;&#x2F;p&gt;
&lt;p&gt;At some point I realized things had to change. There were problems in the API maybe one in five new users would trip over, the backend graphics code was terrifying and unmaintainable, and &lt;code&gt;async&#x2F;await&lt;&#x2F;code&gt; was just around the corner. I could free myself and my users from callback hell! I set about plans for a major new API revision, and got to work. Over the summer of 2019 I laid the foundation for a set of new libraries, to abstract out the parts of Quicksilver that could live separately. By the end of the year they were pretty much all ready; over the course of Chanukah I put out a few blog updates describing them. The next big version of Quicksilver was in sight: all I had to do was re-write the entire thing to use my new foundational libraries.&lt;&#x2F;p&gt;
&lt;p&gt;This year has not been a good year for progress. If I push myself, I can imagine in the next few months I could finish the API revision I started last year. Lots of things have contributed to this slowdown, and sapped my energy: a global pandemic, a move from a full-time student to a full-time worker, the worsening political situation in the United States. But I haven&#x27;t lost the energy to work on side projects entirely. I&#x27;m playing, running, and writing tabletop role-playing games, I&#x27;m reading more than I used to, and I&#x27;m playing around a little with some other hobby software. I just haven&#x27;t been making games, or using Quicksilver.&lt;&#x2F;p&gt;
&lt;p&gt;The work that&#x27;s left isn&#x27;t particularly exciting either. I need to switch away from &lt;code&gt;stdweb&lt;&#x2F;code&gt; (the maintainer seems to have silently disappeared), I need to write boatloads of documentation, I need to investigate and triage a handful of bug reports, and I need to write a library to support audio on desktop and web.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;so-long&quot;&gt;So Long...&lt;&#x2F;h2&gt;
&lt;p&gt;To be frank, I didn&#x27;t get into open source to write software &lt;em&gt;for&lt;&#x2F;em&gt; other people. If other people want software from me, they can pay me for it (which is quite literally my career). I got into open source because I was writing software for myself, and I figured other people might want to check it out. Sure, I &lt;em&gt;wanted&lt;&#x2F;em&gt; people to check it out or use it. It felt great when people started using Quicksilver or posting bugs with projects they were working on. Out of all the game frameworks in the world, someone decided to use mine. How exciting!&lt;&#x2F;p&gt;
&lt;p&gt;Over time my interests have drifted away from game development. I don&#x27;t keep up with the indie game scene, I don&#x27;t enter game jams, I don&#x27;t make little weekend projects. I&#x27;m not longer writing Quicksilver for myself, but I still work on it. For a while (most of last year, in fact), working on the framework was a hobby unto itself. I was solving fun new challenges, and it was great! As the fun new challenges got solved, I became less and less interested, and the things that had been tiny pain points before became less and less bearable.&lt;&#x2F;p&gt;
&lt;p&gt;What makes it all worse is that Quicksilver will never be &lt;em&gt;done.&lt;&#x2F;em&gt; There will always be one more feature, one more request, one more corner to polish. This summer, I was realizing that, and open source burnout was finally catching up with me. Every time I opened the issue tracker or my own notes I would feel dread, and close it without writing a line of code. The abstract idea of happy users was no longer enough to sustain me. I still haven&#x27;t even reached feature parity with the old, non-async version of Quicksilver, and I&#x27;m not sure I ever will. &lt;&#x2F;p&gt;
&lt;p&gt;At some point it struck me: over three years, I had slowly moved from writing software that I was sharing with other people to writing software for other people. Unless things change, I don&#x27;t see myself writing more features for Quicksilver. I can&#x27;t promise sound support, or new documentation, or a smooth migration from &lt;code&gt;stdweb&lt;&#x2F;code&gt; to &lt;code&gt;web-sys&lt;&#x2F;code&gt;. If I can find the time and energy, I might package up the current alpha into an actual release, but I won&#x27;t promise that either.&lt;&#x2F;p&gt;
&lt;p&gt;For now, I have no problem &lt;em&gt;maintaining&lt;&#x2F;em&gt; software. I&#x27;ll be sticking around to triage bug reports, review pull requests, and cut releases (on Quicksilver, all its associated libraries, and Winit). Quicksilver isn&#x27;t going anywhere- but it&#x27;s important I make this explicit. It&#x27;s also not &lt;em&gt;going anywhere&lt;&#x2F;em&gt;. I have no plans to fix the handful of outstanding bugs, or the feature requests, or upstream improvements to other projects.&lt;&#x2F;p&gt;
&lt;p&gt;Here it is important to mention &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bus_factor&quot;&gt;the Bus Factor&lt;&#x2F;a&gt;. Essentially: how many people have to get hit by a bus for your project to completely grind to a halt? In the case of Quicksilver, it has always been 1. Don&#x27;t get me wrong, other people have certainly contributed! Every well-crafted bug report or pull request has great value. At the end of the day, however, I&#x27;m still the single point of failure. That was never going to be a sustainable project structure, and I urge people to consider this concept in open source more generally.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;and-thanks-for-all-the-fish&quot;&gt;...And Thanks for all the Fish&lt;&#x2F;h2&gt;
&lt;p&gt;I don&#x27;t want to give the impression that I regret the project, or wish I hadn&#x27;t done it. Quicksilver was a great project for me to hold on to throughout my time as an undergraduate, and I hope it as brought other people a little bit of the joy it brought me. It couldn&#x27;t have gotten where it was without the Rust community; thank you to the 40 (!) other people who contributed commits, the countless people who filed bugs, and everyone who said kind things online. From the bottom of my heart: thank you.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;re using Quicksilver and it works for you, rock on. If you&#x27;re looking for something else in light of this, I totally understand. For all the reasons mentioned above, I&#x27;m not really plugged in to what the best game-development alternatives are, though I&#x27;ve heard &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bevyengine&#x2F;bevy&quot;&gt;bevy&lt;&#x2F;a&gt; is doing exciting new things.&lt;&#x2F;p&gt;
&lt;p&gt;Good luck, have fun, and make great things.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A New Quicksilver Crate, Elefont</title>
		<published>2020-07-10T00:00:00+00:00</published>
		<updated>2020-07-10T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/announcing-elefont/" type="text/html"/>
		<id>https://ryanisaacg.com/code/announcing-elefont/</id>
		<content type="html">&lt;p&gt;This blog post has been a long time delayed, but late is better than never! The Quicksilver alpha is humming along, with bugs and API problems being addressed. While that work continues, I want to unveil &lt;code&gt;elefont&lt;&#x2F;code&gt;, a crate that I&#x27;ve developed for font caching.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;what-is-elefont&quot;&gt;What is Elefont?&lt;&#x2F;h2&gt;
&lt;p&gt;Elefont is a glyph caching layer, intended to reduce round-trips to the GPU when rendering text.
When a glyph is sent to the GPU, it is stored on a texture and re-used until the cache needs to be refreshed.
Elefont is also designed to support many different font providers, and many different graphics backends: you can currently choose to render with &lt;a href=&quot;https:&#x2F;&#x2F;gitlab.redox-os.org&#x2F;redox-os&#x2F;rusttype&quot;&gt;rusttype&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mooman219&#x2F;fontdue&#x2F;&quot;&gt;fontdue&lt;&#x2F;a&gt;, and there are plans to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ryanisaacg&#x2F;elefont&#x2F;issues&#x2F;5&quot;&gt;support bitmap fonts&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ryanisaacg&#x2F;elefont&#x2F;issues&#x2F;3&quot;&gt;operating-system-specific font toolkits via font_kit&lt;&#x2F;a&gt;. 
It is designed for use primarily in games, because it was written for Quicksilver, and the design reflects that. A GUI toolkit can probably choose a specific font rendering toolkit and use it throughout, but games tend to have more idiosyncratic text requirements (like bitmap fonts.)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-glyph-caching&quot;&gt;What is Glyph Caching?&lt;&#x2F;h2&gt;
&lt;p&gt;Glyph caching is an approach to font rendering that stores each &amp;quot;glyph&amp;quot; (font image) on the GPU. &lt;&#x2F;p&gt;
&lt;aside&gt;
&lt;p&gt;Human writing is vast and complex, and so are the systems we have built to digitize it. A &amp;quot;glyph&amp;quot; is not the same as a &amp;quot;character;&amp;quot; this may surprise people who exclusively use Latin script. For example, Unicode emoji support &lt;a href=&quot;https:&#x2F;&#x2F;emojipedia.org&#x2F;emoji-modifier-sequence&#x2F;&quot;&gt;skin-tone modifiers&lt;&#x2F;a&gt;. These are separate Unicode code-points that are placed &lt;em&gt;after&lt;&#x2F;em&gt; the emoji code-point, and modify the image that is produced. Other familiar examples include all-caps fonts: &#x27;A&#x27; and &#x27;a&#x27; are different characters, but may be represented by the same glyph. For more on the complexity of text rendering, see &lt;a href=&quot;https:&#x2F;&#x2F;gankra.github.io&#x2F;blah&#x2F;text-hates-you&#x2F;&quot;&gt;Text Rendering Hates You&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;aside&gt;
&lt;p&gt;Most fonts are stored in files like &#x27;TTF&#x27; or &#x27;OTF&#x27;. These are called &#x27;vector fonts,&#x27; because the glyphs are stored as a series of strokes; similar technology powers SVG images or Adobe Flash graphics. Every time you render a glyph from one of these fonts, the font system uses a &#x27;rasterizer&#x27; to turn the strokes of the glyph into a grid of pixel color values. This is a fairly expensive operation, so glyph caches store this resulting bitmap instead of re-generating it every time the character is used. Elefont helps in this case by keeping track of a map of glyphs to their rendered counterparts.&lt;&#x2F;p&gt;
&lt;p&gt;Even if you&#x27;re using a &amp;quot;bitmap font&amp;quot; (a font defined by pixel image data instead of vector graphics), you still have to send that image data to the GPU. With the machinery already in place to map from glyphs to rendered images, Elefont can help in this case by keeping track of a map of glyphs to their GPU-side counterparts. This is a high priority for a future version, but isn&#x27;t written yet.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-not-use-x&quot;&gt;Why not use X?&lt;&#x2F;h2&gt;
&lt;p&gt;Initially, I didn&#x27;t expect to write Elefont or anything similar. I knew that Quicksilver 0.4 would need glyph caching, because fonts and text were a significant pain point in Quicksilver 0.3. What I did not find was anything that fit my requirements:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Work with any graphics backend. Quicksilver uses &lt;code&gt;golem&lt;&#x2F;code&gt;, my abstraction layer over OpenGL, so being tied to another graphics library was a no-go&lt;&#x2F;li&gt;
&lt;li&gt;Work with any font provider. Users may have bitmap fonts or vector fonts; they may want system-native font rendering (with some web fallback); they may want the more mature rusttype or the more ambitious fontdue, etc.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;There were other options that pass requirement 1, chief among them &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;glyph-brush&quot;&gt;glyph_brush&lt;&#x2F;a&gt;. However, glyph_brush is tied into rusttype, and doesn&#x27;t seem to be interested in supporting bitmap fonts or other rasterizers. For many uses, glyph_brush is the right choice! However, it just couldn&#x27;t fit my needs. Bitmap fonts are a fairly common request when rendering for games, and a design that precludes them is a missed opportunity.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-comes-next&quot;&gt;What Comes Next?&lt;&#x2F;h2&gt;
&lt;p&gt;(Hopefully soon) I&#x27;ll be putting out a State of Quicksilver update, that generally addresses progress the project has made this year!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Website Makeover, Again</title>
		<published>2020-05-24T00:00:00+00:00</published>
		<updated>2020-05-24T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/new-blog-2/" type="text/html"/>
		<id>https://ryanisaacg.com/code/new-blog-2/</id>
		<content type="html">&lt;p&gt;Out with the old, in with the new! After some frustration with Hugo, I&#x27;ve moved to &lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;&quot;&gt;Zola&lt;&#x2F;a&gt; and some light CSS.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;I wanted to write a new blog post regarding &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ryanisaacg&#x2F;elefont&quot;&gt;elefont&lt;&#x2F;a&gt; and Quicksilver&#x27;s new text rendering system, but I  was dreading making a post on the site. Hugo had proved opaque and fragile for me, and its blizzard of configuration options wasn&#x27;t making things much easier. Plus, something small broke when I tried to use the latest Hugo version on Windows to re-build the site. I wasn&#x27;t much interested in tracking down a changelog and bringing my blog up to the latest version, so I decided Hugo had to go.&lt;&#x2F;p&gt;
&lt;p&gt;Initially I considered writing my own static site generator. &lt;em&gt;How hard could it be?&lt;&#x2F;em&gt; I asked myself. Then I thought about generating an RSS feed, and parsing front-matter, and maybe setting up a SASS compilation pipeline. &lt;em&gt;No thanks!&lt;&#x2F;em&gt; I instead settled on Zola, primarily because it seems to be the right combination of simple and expressive. Secondarily, it&#x27;s written in Rust, which I appreciate. Using Zola has been very nice so far; I feel more like I&#x27;m programming a little language designed to make website-making easy. Previous experiences with Hugo and Jekyll felt more like wrestling the generator into doing what I wanted; Zola is a breath of fresh air by comparison.&lt;&#x2F;p&gt;
&lt;p&gt;Currently the site is very light on styling. So far I like the look of it, but for how long is anyone&#x27;s guess.&lt;&#x2F;p&gt;
&lt;p&gt;I hope this means I can get some posts up about Quicksilver soon; there&#x27;s been a lot of evolution since the end of last year, when I was just starting on the new alpha versions. I ended up forgoing a State of Quicksilver 2020, for a few reasons:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019&quot;&gt;The Quicksilver Chanukah posts&lt;&#x2F;a&gt; covered a lot of my plans&lt;&#x2F;li&gt;
&lt;li&gt;I wanted to wait until the 0.4 release is closer to feature-complete&lt;&#x2F;li&gt;
&lt;li&gt;And mostly, I&#x27;ve been very busy&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Post-script update, as of June 8th 2020: The blog is a bit more automatic! Previously I was just pushing up new built versions of the site to Github Pages, but that gets tedious. I set up Github Actions to run on any push to ryanisaacg&#x2F;blog on master; now the blog is automatically built and deployed.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Quicksilver Chanukah, Day 8: Rust Gamedev and the Web</title>
		<published>2019-12-29T00:00:00+00:00</published>
		<updated>2019-12-29T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-8/" type="text/html"/>
		<id>https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-8/</id>
		<content type="html">&lt;p&gt;This year has been great for Rust gamedev on the web. Huge progress has been made towards a full game stack being available more-or-less &amp;quot;for free:&amp;quot; most of the foundational crates have available web support, in one way or another.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;windowing-and-input&quot;&gt;Windowing and Input&lt;&#x2F;h2&gt;
&lt;p&gt;For opening a window and receiving events from it, the Rust ecosystem has &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-windowing&#x2F;winit&quot;&gt;&lt;code&gt;winit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. Along with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;hecrj&quot;&gt;Héctor Ramón (hecrj)&lt;&#x2F;a&gt; and and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;blm768&quot;&gt;Ben Merritt (blm768)&lt;&#x2F;a&gt;, I worked on adding web support. &lt;a href=&quot;https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;winit-0-20-and-web-support&#x2F;36155&quot;&gt;It has been merged and released&lt;&#x2F;a&gt;, and is used in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;hecrj&#x2F;coffee&quot;&gt;coffee&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ryanisaacg&#x2F;blinds&quot;&gt;blinds&lt;&#x2F;a&gt;. While using &lt;code&gt;winit&lt;&#x2F;code&gt; directly does require some glue code to plug your canvas into the webpage, intermediate layers like game frameworks can take care of the details.&lt;&#x2F;p&gt;
&lt;p&gt;While &lt;code&gt;winit&lt;&#x2F;code&gt; doesn&#x27;t currently provide gamepad events, &lt;a href=&quot;https:&#x2F;&#x2F;gitlab.com&#x2F;gilrs-project&#x2F;gilrs&quot;&gt;&lt;code&gt;gilrs&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; fills that gap nicely. In the beginning of the year I added web support via stdweb, which should translate to &lt;code&gt;wasm-bindgen&lt;&#x2F;code&gt; when necessary. Unlike &lt;code&gt;winit&lt;&#x2F;code&gt;, which requires a little glue code to connect to your webpage, &lt;code&gt;gilrs&lt;&#x2F;code&gt; Just Works. It functions nearly the same as the desktop version, with the only limitations being those the web platform imposes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;graphics&quot;&gt;Graphics&lt;&#x2F;h2&gt;
&lt;p&gt;When it comes to graphics on the web, there are two APIs to keep in mind. One is WebGL, which is the current way of writing graphics code for the web. The other is WebGPU, an evolving standard based on newer, more modern APIs that will be the way forward. Currently WebGPU is just in the draft phase, so we can&#x27;t target it just yet. Targeting WebGL directly is an option, but it seems like a waste to write OpenGL code for desktop and then again for web. Enter &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;grovesNL&#x2F;glow&quot;&gt;&lt;code&gt;glow&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which brings a unified API across destop and WebGL.&lt;&#x2F;p&gt;
&lt;p&gt;Built on top of &lt;code&gt;glow&lt;&#x2F;code&gt; is &lt;code&gt;gfx-backend-gl&lt;&#x2F;code&gt;, which brings &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;gfx-rs&#x2F;gfx&quot;&gt;&lt;code&gt;gfx-hal&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to desktop GL and web. By extension comes &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;gfx-rs&#x2F;wgpu-rs&quot;&gt;&lt;code&gt;wgpu&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, an idiomatic Rust implementation of the upcoming WebGPU specification. It uses WebGL for now, but when WebGPU is stabilization and available, we&#x27;ll have a modern graphics API that works seamlessly across desktop and web.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;audio&quot;&gt;Audio&lt;&#x2F;h2&gt;
&lt;p&gt;The audio story for Rust on the web is not there yet, unfortunately. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RustAudio&#x2F;cpal&quot;&gt;&lt;code&gt;cpal&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, a cross-platform library for Rust audio, doesn&#x27;t have web support yet. However, there is hope! &lt;a href=&quot;https:&#x2F;&#x2F;nannou.cc&#x2F;posts&#x2F;moss_grant_announce&quot;&gt;Mozilla announced a grant to Nannou&lt;&#x2F;a&gt; that includes web support in &lt;code&gt;cpal&lt;&#x2F;code&gt; as a core goal. The relevant issue is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RustAudio&#x2F;cpal&#x2F;issues&#x2F;212&quot;&gt;cpal #212&lt;&#x2F;a&gt;, which will hopefully yield some information early next year.&lt;&#x2F;p&gt;
&lt;p&gt;That&#x27;s it for my updates! This was a good year for Rust on the web, and laid the groundwork for the changes I&#x27;ve talked about in Quicksilver. I&#x27;ll be back in the new year with a State of Quicksilver 2020, which should come along with an alpha release of the new Quicksilver version.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;re interested in updates from other places in the Rust ecosystem, check out the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.alopex.li&#x2F;TheStateOfGGEZ2020&quot;&gt;State of GGEZ 2020&lt;&#x2F;a&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;rust-gamedev.github.io&#x2F;&quot;&gt;Rust Gamedev Working Group&#x27;s newsletters&lt;&#x2F;a&gt;. See you in the new year!&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;quicksilver-chanukah-2019&quot;&gt;The introduction post&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;quicksilver-chanukah-2019-day-2&quot;&gt;&lt;code&gt;platter&lt;&#x2F;code&gt;: An async file-loading API for desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;quicksilver-chanukah-2019-day-3&quot;&gt;&lt;code&gt;gestalt&lt;&#x2F;code&gt;: An API to manage bundling and saving data locally on desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;quicksilver-chanukah-2019-day-4&quot;&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt;: An easy-to-use async wrapper of &lt;code&gt;winit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;quicksilver-chanukah-2019-day-5&quot;&gt;&lt;code&gt;golem&lt;&#x2F;code&gt;: An opinionated mostly-safe graphics library for desktop and web GL&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;quicksilver-chanukah-2019-day-6&quot;&gt;Changes to the Quicksilver application lifecycle&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-7&quot;&gt;Changes to the Quicksilver graphics API&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;This post!&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Quicksilver Chanukah, Day 7: Quicksilver&#x27;s New Graphics</title>
		<published>2019-12-28T00:00:00+00:00</published>
		<updated>2019-12-28T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-7/" type="text/html"/>
		<id>https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-7/</id>
		<content type="html">&lt;p&gt;The graphics API of Quicksilver isn&#x27;t as dire need of a rework as the &lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-6&quot;&gt;lifecycle APIs&lt;&#x2F;a&gt;, but I wanted to take the next breaking change as an opportunity to address some long-standing issues. &lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;In no particular order, they are:&lt;&#x2F;p&gt;
&lt;h2 id=&quot;low-level-access&quot;&gt;Low-Level Access&lt;&#x2F;h2&gt;
&lt;p&gt;As it stands, Quicksilver talks to a very specific backend design for graphics. The API is internal-only and designed to wrap up all the GL code in one place, to keep the high-level drawing APIs platform independent. There&#x27;s no way to expose the raw GL API directly to the user, as the backend talks directly to OpenGL 3.2 and WebGL 1. With &lt;code&gt;glow&lt;&#x2F;code&gt;, we could expose a cross-platform OpenGL context, but there are still differences between desktop and web GL. These problems, like different ways of describing the input and output in GLSL, are addressed by &lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-5&quot;&gt;&lt;code&gt;golem&lt;&#x2F;code&gt; (see announcement from 2 days ago.)&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Providing users access to a lower-level graphics API also frees the high-level API from trying to provide custom shader support. A custom shader is best served with custom vertex inputs, which means custom functions to turn high-level draw commands into low-level vertex data. Instead of trying to solve this problem in the general case, Quicksilver can provide the mechanism to solve it yourself.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;draw-order&quot;&gt;Draw Order&lt;&#x2F;h2&gt;
&lt;p&gt;The previous graphics API aggressively batches draws, including re-ordering &lt;code&gt;draw&lt;&#x2F;code&gt; commands to avoid changing state while rendering. If a &lt;code&gt;z&lt;&#x2F;code&gt; parameter (not included in the default, simple &lt;code&gt;draw&lt;&#x2F;code&gt;) is not provided, anything goes. Hypothetically this leads to faster rendering, but it also means that many users experience unexpected results with basic operations. The new API should be built on a simple draw-order guarantee: the first draw call is drawn furthest back, with each subsequent draw lying on top of the ones before it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;render-to-texture&quot;&gt;Render-To-Texture&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;Surface&lt;&#x2F;code&gt; API supports render-to-texture, but it has a few problems. First, the API is unintuitive: rendering to a texture only works within a closure, for example. Also, it&#x27;s plain buggy. &lt;code&gt;golem&lt;&#x2F;code&gt; provides a harder-to-misuse API for off-screen rendering, which can be used to build a nicer abstraction in Quicksilver itself.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;screen-resizing-and-projection&quot;&gt;Screen Resizing and Projection&lt;&#x2F;h2&gt;
&lt;p&gt;The current version of Quicksilver &amp;quot;magically&amp;quot; handles the window being resized, as well as projecting and unprojecting between world and screen coordinates. Often this is more trouble than it&#x27;s worth: you want your UI at one projection and letterbox, and your game content at another. By exposing a few more knobs to the user (like the GL viewport), the &lt;code&gt;ResizeStrategy&lt;&#x2F;code&gt; API can be provided on top of other, orthogonal abstractions.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019&quot;&gt;The introduction post&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-2&quot;&gt;&lt;code&gt;platter&lt;&#x2F;code&gt;: An async file-loading API for desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-3&quot;&gt;&lt;code&gt;gestalt&lt;&#x2F;code&gt;: An API to manage bundling and saving data locally on desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-4&quot;&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt;: An easy-to-use async wrapper of &lt;code&gt;winit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-5&quot;&gt;&lt;code&gt;golem&lt;&#x2F;code&gt;: An opinionated mostly-safe graphics library for desktop and web GL&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-6&quot;&gt;Changes to the Quicksilver application lifecycle&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;This post!&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-8&quot;&gt;An overview of the work on web support this year&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Quicksilver Chanukah, Day 6: Quicksilver&#x27;s New Lifecycle</title>
		<published>2019-12-27T00:00:00+00:00</published>
		<updated>2019-12-27T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-6/" type="text/html"/>
		<id>https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-6/</id>
		<content type="html">&lt;p&gt;Quicksilver has always had some major API compromises to deliver on its core promise: write a game once, and it targets desktop and the web with no changes. The two ugliest compromises are the &lt;code&gt;State&lt;&#x2F;code&gt; and &lt;code&gt;Asset&lt;&#x2F;code&gt; APIs, for managing your application&#x27;s core loop and file loading, respectively.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;&lt;code&gt;State&lt;&#x2F;code&gt; is a trait that Quicksilver uses to manage when your code runs. It requires you define the &lt;code&gt;new&lt;&#x2F;code&gt; method, as well as &lt;code&gt;draw&lt;&#x2F;code&gt;. Optionally you can define &lt;code&gt;update&lt;&#x2F;code&gt;, for a fixed tick rate function, and &lt;code&gt;event&lt;&#x2F;code&gt; for handling individual input events. This type then gets passed as a generic parameter to the &lt;code&gt;run&lt;&#x2F;code&gt; function, which handles instantiating it and running the event loop. The downside is that the user gets very little say in how their code is arranged, but the benefit is that your code runs on web without blocking the main thread (which will lock up the tab.)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Asset&lt;&#x2F;code&gt; is a wrapper around &lt;code&gt;Future&lt;&#x2F;code&gt;, which is an asychronous action in Rust. The point of the &lt;code&gt;Asset&lt;&#x2F;code&gt; API was to avoid users having to manually poll their futures to check if they&#x27;re ready: just use an &lt;code&gt;Asset&lt;&#x2F;code&gt; and its execute method, which will run a closure if its &lt;code&gt;Future&lt;&#x2F;code&gt; is completed. Unfortunately, this turns out not to be very ergonomic. &lt;code&gt;Asset&lt;&#x2F;code&gt; is a pain to use, and a point of confusion for most users. There&#x27;s no way around asychronous file loading on the web, but new developments in Rust have made much better solutions possible.&lt;&#x2F;p&gt;
&lt;p&gt;Readers of previous posts may notice that these two API problems are addressed by two of the crates I announced this week: &lt;code&gt;blinds&lt;&#x2F;code&gt; to address &lt;code&gt;State&lt;&#x2F;code&gt; and &lt;code&gt;platter&lt;&#x2F;code&gt; to address &lt;code&gt;Asset&lt;&#x2F;code&gt;. Where before, you might write something like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct MyState {
    images: Asset&amp;lt;Vec&amp;lt;Image&amp;gt;&amp;gt;,
    game: Game,
}

impl State for MyState {
    fn new() -&amp;gt; MyState {
        MyState {
            images: Asset::new(join_all(vec![Image::load(&amp;quot;a&amp;quot;), Image::load(&amp;quot;b&amp;quot;), Image::load(&amp;quot;c&amp;quot;)])),
            game: Game::new()
        }
    }

    fn event(&amp;amp;mut self, _win: &amp;amp;mut Window, ev: &amp;amp;Event) {
        self.images.execute(|images| {
            self.game.process_event(ev);
        });
    }

    fn update(&amp;amp;mut self, _win: &amp;amp;mut Window) {
        self.images.execute(|images| {
            self.game.update();
        });
    }

    fn draw(&amp;amp;mut self, win: &amp;amp;mut Window) {
        self.images.execute(|images| {
            self.game.draw(&amp;amp;images, win);
        });
    }
}

fn main() {
    run::&amp;lt;MyState&amp;gt;();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;you could now write something like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;async fn my_game(win: Window, mut gfx: Graphics, events: EventStream) {
    let mut game = Game::new();
    let images = join_all(vec![Image::load(&amp;quot;a&amp;quot;), Image::load(&amp;quot;b&amp;quot;), Image::load(&amp;quot;c&amp;quot;)]).await;
    loop {
        while let Some(ev) = events.next_event().await {
            game.process_event(ev);
        }
        game.update();
        game.draw(&amp;amp;mut gfx);
        gfx.present(&amp;amp;win);
    }
}

fn main() {
    run(my_game);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you want to know more, check out &lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-4&quot;&gt;my post about blinds&lt;&#x2F;a&gt; for more details on the event loop and &lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-2&quot;&gt;my post about platter&lt;&#x2F;a&gt; for more details on async file loading.&lt;&#x2F;p&gt;
&lt;p&gt;As a side effect of the async API, the user has a lot more control over when their code runs. Previously Quicksilver managed your update timing automatically: it would aim for 60Hz by default, regardless of how long updates take. Now you&#x27;re in charge of your own timing, though features to make timing fire-and-forget could become part of the final release.&lt;&#x2F;p&gt;
&lt;p&gt;Speaking of releases, I hope to have a very early alpha of this version of Quicksilver out within the next week or so. It will be a very bare-bones version: just the event loop and some small graphics functions for now, which I&#x27;ll go into more depth about tomorrow.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019&quot;&gt;The introduction post&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-2&quot;&gt;&lt;code&gt;platter&lt;&#x2F;code&gt;: An async file-loading API for desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-3&quot;&gt;&lt;code&gt;gestalt&lt;&#x2F;code&gt;: An API to manage bundling and saving data locally on desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-4&quot;&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt;: An easy-to-use async wrapper of &lt;code&gt;winit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-5&quot;&gt;&lt;code&gt;golem&lt;&#x2F;code&gt;: An opinionated mostly-safe graphics library for desktop and web GL&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;This post!&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-7&quot;&gt;Changes to the Quicksilver graphics API&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-8&quot;&gt;An overview of the work on web support this year&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Quicksilver Chanukah, Day 5: Golem</title>
		<published>2019-12-26T00:00:00+00:00</published>
		<updated>2019-12-26T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-5/" type="text/html"/>
		<id>https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-5/</id>
		<content type="html">&lt;p&gt;&lt;code&gt;golem&lt;&#x2F;code&gt; is a mostly-safe graphics API that targets OpenGL 3.2 and WebGL 1 that helps make writing GL less painful.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;why-golem-and-not-x&quot;&gt;Why &lt;code&gt;golem&lt;&#x2F;code&gt; and not X&lt;&#x2F;h2&gt;
&lt;p&gt;If you&#x27;re just interested in what &lt;code&gt;golem&lt;&#x2F;code&gt; is and how it works, feel free to skip this section!&lt;&#x2F;p&gt;
&lt;p&gt;The previous three days I&#x27;ve introduced new crates that mostly stood on their own. I&#x27;m not aware of any fleshed-out alternatives, so creating those libraries myself doesn&#x27;t require much explanation. &lt;code&gt;golem&lt;&#x2F;code&gt;, however, is a different story: there aren&#x27;t exactly a shortage of Rust graphics libraries. There are a variety of reasons as to why none of them fit Quicksilver&#x27;s needs, most of which revolve around support for older hardware or older APIs. For brevity, I&#x27;d recommend you check out &lt;a href=&quot;https:&#x2F;&#x2F;wiki.alopex.li&#x2F;AGuideToRustGraphicsLibraries2019&quot;&gt;icefox&#x27;s guide to the existing graphics options&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I have a test device that I think is a good benchmark for something Quicksilver-powered games should be able to target, and it doesn&#x27;t support Vulkan. This eliminates &lt;code&gt;ash&lt;&#x2F;code&gt; and &lt;code&gt;vulkano&lt;&#x2F;code&gt; straight off the bat, and &lt;code&gt;gfx-hal&lt;&#x2F;code&gt; as well. &lt;code&gt;ash&lt;&#x2F;code&gt; and &lt;code&gt;vulkano&lt;&#x2F;code&gt; target Vulkan directly, and &lt;code&gt;gfx-hal&lt;&#x2F;code&gt;&#x27;s OpenGL backend is not currently reliable enough (though I hope to see that improve!)&lt;&#x2F;p&gt;
&lt;p&gt;I also want to be able to support WebGL 1, but WebGL 1 is not a very modern version of OpenGL. This makes it, for good reaon, unattractive to other libraries (like &lt;code&gt;luminance&lt;&#x2F;code&gt;, which is targeting WebGL 2 in its upcoming web support). However, WebGL 2&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;caniuse.com&#x2F;#feat=webgl2&quot;&gt;market share&lt;&#x2F;a&gt; still hovers at around 75%, which isn&#x27;t ideal; notably missing from WebGL 2 support are the current verisons of Edge, Safari, and iOS Safari. Quicksilver recently transitioned to using WebGL 1 for better platform support, and I didn&#x27;t want to regress by requiring a high version. This rules out &lt;code&gt;luminance&lt;&#x2F;code&gt;, and presumably &lt;code&gt;glium&lt;&#x2F;code&gt; (which has no current development towards web support as far as I&#x27;m aware.)&lt;&#x2F;p&gt;
&lt;p&gt;With just those two constraints I&#x27;m out of options, so I decided to write &lt;code&gt;golem&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mostly-safe&quot;&gt;Mostly-Safe?&lt;&#x2F;h2&gt;
&lt;p&gt;Where possible, &lt;code&gt;golem&lt;&#x2F;code&gt; handles for you the complex state machine of OpenGL. In other places, it prevents you from using resources that haven&#x27;t been properly set-up. In these cases, &lt;code&gt;golem&lt;&#x2F;code&gt; is safe with low-overhead, removing footguns from OpenGL without slowing your code down. In others, more overhead would be required to keep the API free of &lt;code&gt;unsafe&lt;&#x2F;code&gt;. Currently only two functions are marked as &lt;code&gt;unsafe&lt;&#x2F;code&gt; in &lt;code&gt;golem&lt;&#x2F;code&gt;&#x27;s public API, but they are the only functions that draw things to the screen! This means using &lt;code&gt;unsafe&lt;&#x2F;code&gt; code as a consumer of &lt;code&gt;golem&lt;&#x2F;code&gt; is unavoidable, hence &amp;quot;mostly-safe.&amp;quot;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-code-snippet&quot;&gt;A Code Snippet&lt;&#x2F;h2&gt;
&lt;p&gt;Hopefully if you&#x27;re familiar with graphics APIs, this code snippet to draw a triangle to the screen will look a little familiar. If not, the comments should help you follow along!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use blinds::*;
use golem::{
    Attribute, AttributeType, Context,
    Dimension::{D2, D4},
    ElementBuffer, GeometryMode, GolemError, ShaderDescription, ShaderProgram, VertexBuffer,
};

&amp;#x2F;&amp;#x2F; The application loop, powered by the blinds crate
async fn app(
    window: Window,
    ctx: glow::Context,
    mut events: EventStream,
) -&amp;gt; Result&amp;lt;(), GolemError&amp;gt; {
    &amp;#x2F;&amp;#x2F; Create a context from &amp;#x27;glow&amp;#x27;, GL On Whatever
    let ctx = &amp;amp;Context::from_glow(ctx)?;

    #[rustfmt::skip]
    &amp;#x2F;&amp;#x2F; This is the data that represents the triangle
    &amp;#x2F;&amp;#x2F; It&amp;#x27;s arranged how it will be passed to the GPU: each position represented as two f32 values,
    &amp;#x2F;&amp;#x2F; followed by each color represented as 4 f32 values. The positions are on a scale from -1.0
    &amp;#x2F;&amp;#x2F; to 1.0, which represents the viewport in OpenGL. The colors are represented as R, G, B, A,
    &amp;#x2F;&amp;#x2F; on a scale from 0.0 to 1.0
    let vertices = [
        &amp;#x2F;&amp;#x2F; Position         Color
        -0.5, -0.5,         1.0, 0.0, 0.0, 1.0,
        0.5, -0.5,          0.0, 1.0, 0.0, 1.0,
        0.0, 0.5,           0.0, 0.0, 1.0, 1.0
    ];
    &amp;#x2F;&amp;#x2F; This is the data that indicates how to draw the vertices
    &amp;#x2F;&amp;#x2F; For a simple example of one triangle, we don&amp;#x27;t gain much from this. Any order of these three
    &amp;#x2F;&amp;#x2F; points will give us the same triangle. However, if we add more points (to draw a square, for
    &amp;#x2F;&amp;#x2F; example), then we can write each point once while using it in multiple triangles.
    let indices = [0, 1, 2];

    &amp;#x2F;&amp;#x2F; Here we create the ShaderProgram, which is some code that runs on the GPU. It determines how
    &amp;#x2F;&amp;#x2F; to turn our vertex data into an actual vertex that GL understands, and how to color each
    &amp;#x2F;&amp;#x2F; &amp;#x27;fragment&amp;#x27; (essentially a pixel). These are each their own little program, where the
    &amp;#x2F;&amp;#x2F; information from the vertex shader is fed into the fragment shader.
    &amp;#x2F;&amp;#x2F; For the purposes of making sure the shaders match, and for ensuring compatibility on desktop
    &amp;#x2F;&amp;#x2F; and web, the inputs are represented as data structures and then converted to shader
    &amp;#x2F;&amp;#x2F; declarations at runtime.
    &amp;#x2F;&amp;#x2F; The input to the shader program is fed to the vertex_input, so your vertex data&amp;#x27;s format
    &amp;#x2F;&amp;#x2F; needs to match what you define in vertex_input
    let mut shader = ShaderProgram::new(
        ctx,
        ShaderDescription {
            &amp;#x2F;&amp;#x2F; Take in to the shader a position (as a vector with 2 components) and a color (as a
            &amp;#x2F;&amp;#x2F; vector with 4 components). This is the same format as &amp;#x27;vertices&amp;#x27; above
            vertex_input: &amp;amp;[
                Attribute::new(&amp;quot;vert_position&amp;quot;, AttributeType::Vector(D2)),
                Attribute::new(&amp;quot;vert_color&amp;quot;, AttributeType::Vector(D4)),
            ],
            &amp;#x2F;&amp;#x2F; Pass to the fragment shader the color
            &amp;#x2F;&amp;#x2F; OpenGL will actually smoothly interpolate between different vertex values for us, so
            &amp;#x2F;&amp;#x2F; a red vertex and a blue vertex will have a gradient between them
            fragment_input: &amp;amp;[Attribute::new(&amp;quot;frag_color&amp;quot;, AttributeType::Vector(D4))],
            &amp;#x2F;&amp;#x2F; Uniforms represent a value that&amp;#x27;s the same for the entire shader; we don&amp;#x27;t need any
            &amp;#x2F;&amp;#x2F; here. If you&amp;#x27;re rendering images or applying transformations to your entire draw
            &amp;#x2F;&amp;#x2F; call, use uniforms!
            uniforms: &amp;amp;[],
            &amp;#x2F;&amp;#x2F; A program written in GLSL that uses the inputs and outputs defined above
            &amp;#x2F;&amp;#x2F; There&amp;#x27;s also a hard-coded output called gl_Position
            vertex_shader: r#&amp;quot; void main() {
            gl_Position = vec4(vert_position, 0, 1);
            frag_color = vert_color;
        }&amp;quot;#,
            &amp;#x2F;&amp;#x2F; The fragment shader has a hard-coded output: gl_FragColor
            fragment_shader: r#&amp;quot; void main() {
            gl_FragColor = frag_color;
        }&amp;quot;#,
        },
    )?;

    &amp;#x2F;&amp;#x2F; Create buffer objects, which we use to transfer data from the CPU to the GPU
    let mut vb = VertexBuffer::new(ctx)?;
    let mut eb = ElementBuffer::new(ctx)?;
    &amp;#x2F;&amp;#x2F; Set the data of the buffer to be our vertices and indices from earlier
    vb.set_data(&amp;amp;vertices);
    eb.set_data(&amp;amp;indices);
    &amp;#x2F;&amp;#x2F; Prepare the shader for operations: shaders will raise errors if you forget to bind them
    shader.bind();
    &amp;#x2F;&amp;#x2F; Clear the screen
    ctx.clear();
    unsafe {
        &amp;#x2F;&amp;#x2F; Using our buffers, draw our triangle
        &amp;#x2F;&amp;#x2F; We could also interpert our indices as Lines or a variety of other shape options:
        &amp;#x2F;&amp;#x2F; nothing binds us to necessarily using Triangles, even though they&amp;#x27;re the most common
        &amp;#x2F;&amp;#x2F; shape in graphics
        shader.draw(&amp;amp;vb, &amp;amp;eb, 0..indices.len(), GeometryMode::Triangles)?;
    }
    &amp;#x2F;&amp;#x2F; Show our data to the window
    window.present();
    &amp;#x2F;&amp;#x2F; Keep the window open and responsive until the user exits
    loop {
        events.next_event().await;
    }
}

&amp;#x2F;&amp;#x2F; Run our application!
fn main() {
    run_gl(Settings::default(), |window, gfx, events| {
        async move { app(window, gfx, events).await.unwrap() }
    });
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(This is also an example of &lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-4&quot;&gt;yesterday&#x27;s &lt;code&gt;blinds&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and its OpenGL support.)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-development&quot;&gt;Further Development&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;golem&lt;&#x2F;code&gt; is not intended to be a fully-featured wrapper around all of OpenGL. It&#x27;s intended to be enough to write fairly complex 2D graphics, or fairly simple 3D graphics. That said, there is a lot that&#x27;s missing! Some of it is documented on the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ryanisaacg&#x2F;golem&#x2F;issues&quot;&gt;issue tracker&lt;&#x2F;a&gt;, but I&#x27;m sure that I&#x27;ve missed other things. Nearly everything I need for Quicksilver is done, but your use case might be different. Feel free to open an issue discussing a feature addition, or try and experiment with a fork for larger changes.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;golem&lt;&#x2F;code&gt; is the last new crate to announce, which means tomorrow is about what these crates enable: the new version of Quicksilver.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019&quot;&gt;The introduction post&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-2&quot;&gt;&lt;code&gt;platter&lt;&#x2F;code&gt;: An async file-loading API for desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-3&quot;&gt;&lt;code&gt;gestalt&lt;&#x2F;code&gt;: An API to manage bundling and saving data locally on desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-4&quot;&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt;: An easy-to-use async wrapper of &lt;code&gt;winit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;This post!&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-day-6&quot;&gt;Changes to the Quicksilver application lifecycle&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-7&quot;&gt;Changes to the Quicksilver graphics API&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-8&quot;&gt;An overview of the work on web support this year&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Quicksilver Chanukah, Day 4: Blinds</title>
		<published>2019-12-25T00:00:00+00:00</published>
		<updated>2019-12-25T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-4/" type="text/html"/>
		<id>https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-4/</id>
		<content type="html">&lt;p&gt;With the recent update to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-windowing&#x2F;winit&quot;&gt;&lt;code&gt;winit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, it gained web support! This is great, and it means that Quicksilver doesn&#x27;t need to have its own parallel implementation of windowing. However, there is room for an abstraction that&#x27;s a little simpler than Winit, and takes advantage of &lt;code&gt;async&#x2F;.await&lt;&#x2F;code&gt;, which is where &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;blinds&quot;&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; comes in.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt; is based on &lt;code&gt;winit&lt;&#x2F;code&gt;, but focused on Quicksilver&#x27;s specific use case of single-window games on desktop and web. It also integrates &lt;code&gt;gilrs&lt;&#x2F;code&gt; for gamepad support (though this could be provided directly by &lt;code&gt;winit&lt;&#x2F;code&gt; later), without exposing either in its external API. Additionally, &lt;code&gt;blinds&lt;&#x2F;code&gt; has optional support for OpenGL, via &lt;code&gt;glow&lt;&#x2F;code&gt; for uniform bindings across web and desktop.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;async&lt;&#x2F;code&gt; API works via the &lt;code&gt;LocalPool&lt;&#x2F;code&gt; and the &lt;code&gt;winit&lt;&#x2F;code&gt; event loop, allowing you to write code that &lt;em&gt;almost&lt;&#x2F;em&gt; looks like a synchronous event loop.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use blinds::{run, Event, EventStream, Key, Settings, Window};

run(Settings::default(), app);

async fn app(_window: Window, mut events: EventStream) {
    loop {
        while let Some(ev) = events.next_event().await {
            &amp;#x2F;&amp;#x2F; Process your events here!
        }
        &amp;#x2F;&amp;#x2F; Process your frame here!
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The use of &lt;code&gt;.await&lt;&#x2F;code&gt; here is a bit of a hack, as it allows the event loop to wrest control away from the user and return it to the browser without blocking. Compare this to the comparable snippet from the legacy Quicksilver API:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use quicksilver::{
    Result,
    geom::Vector,
    lifecycle::{Event, Settings, State, Window, run},
};

struct HelloWorld;

impl State for HelloWorld {
    fn new() -&amp;gt; Result&amp;lt;HelloWorld&amp;gt; {
        Ok(HelloWorld)
    }
    
    fn event(&amp;amp;mut self, window: &amp;amp;mut Window, event: &amp;amp;Event) -&amp;gt; Result&amp;lt;()&amp;gt; {
        &amp;#x2F;&amp;#x2F; Process events here
        Ok(())
    }
    
    fn update(&amp;amp;mut self, window: &amp;amp;mut Window) -&amp;gt; Result&amp;lt;()&amp;gt; {
        &amp;#x2F;&amp;#x2F; Update here
        Ok(())
    }

    fn draw(&amp;amp;mut self, window: &amp;amp;mut Window) -&amp;gt; Result&amp;lt;()&amp;gt; {
        &amp;#x2F;&amp;#x2F; Draw here
        Ok(())
    }
}

fn main() {
    run::&amp;lt;HelloWorld&amp;gt;(&amp;quot;Hello World&amp;quot;, Vector::new(800, 600), Settings::default());
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;async&lt;&#x2F;code&gt; API isn&#x27;t just way more convenient than the previous, trait-based system. It also allows you to use other &lt;code&gt;async&lt;&#x2F;code&gt; APIs (like &lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-2&quot;&gt;day 2&#x27;s &lt;code&gt;platter&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;), which is important for web support.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt; isn&#x27;t quite ready for a full release yet: there are a few more window APIs I do want to expose before it leaves alpha. However, you can still try it out, just be aware that the API is fairly unstable and likely to change between multiple times before the first non-alpha release!&lt;&#x2F;p&gt;
&lt;p&gt;With &lt;code&gt;blinds&lt;&#x2F;code&gt; today, tomorrow will be the last new crate: &lt;code&gt;golem&lt;&#x2F;code&gt;!&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019&quot;&gt;The introduction post&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-2&quot;&gt;&lt;code&gt;platter&lt;&#x2F;code&gt;: An async file-loading API for desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-3&quot;&gt;&lt;code&gt;gestalt&lt;&#x2F;code&gt;: An API to manage bundling and saving data locally on desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;This post!&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-5&quot;&gt;&lt;code&gt;golem&lt;&#x2F;code&gt;: An opinionated mostly-safe graphics library for desktop and web GL&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-day-6&quot;&gt;Changes to the Quicksilver application lifecycle&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-7&quot;&gt;Changes to the Quicksilver graphics API&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-8&quot;&gt;An overview of the work on web support this year&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Quicksilver Chanukah, Day 3: Gestalt</title>
		<published>2019-12-24T00:00:00+00:00</published>
		<updated>2019-12-24T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-3/" type="text/html"/>
		<id>https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-3/</id>
		<content type="html">&lt;p&gt;Often your application might want to store gamestate or configurations, but the web has no filesystem access. Additionally, you don&#x27;t want to just dump files in the user&#x27;s home directory; each desktop operating system has a different preferred location for storing application-specific data, and often different locations for different kinds of data.&lt;&#x2F;p&gt;
&lt;p&gt;Introducing &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;gestalt&quot;&gt;&lt;code&gt;gestalt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, a library that bundles up your data and stores it away so you don&#x27;t have to.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;A sample to save some game state:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use gestalt::{Location, save, load};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Player {
    name: String,
    score: u32
}

let player1 = Player { name: &amp;quot;Bob&amp;quot;.to_string(), score: 21 };
save(Location::Cache, &amp;quot;mygame&amp;quot;, &amp;quot;player1&amp;quot;, &amp;amp;player1).expect(&amp;quot;Could not save Player 1&amp;quot;);

let player2 = Player { name: &amp;quot;Alice&amp;quot;.to_string(), score: 200 };
save(Location::Cache, &amp;quot;mygame&amp;quot;, &amp;quot;player2&amp;quot;, &amp;amp;player2).expect(&amp;quot;Could not save Player 2&amp;quot;);

&amp;#x2F;&amp;#x2F; Now reload.
let player1 = load::&amp;lt;Player&amp;gt;(Location::Cache, &amp;quot;mygame&amp;quot;, &amp;quot;player1&amp;quot;).expect(&amp;quot;Could not load Player 1&amp;quot;);
let player2 = load::&amp;lt;Player&amp;gt;(Location::Cache, &amp;quot;mygame&amp;quot;, &amp;quot;player2&amp;quot;).expect(&amp;quot;Could not load Player 2&amp;quot;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Getsalt creates a Key&#x2F;Value store, backed by the filesystem on desktop and the web storage API. The key is formed by &lt;code&gt;Location&lt;&#x2F;code&gt;, which determines the kind of data (&lt;code&gt;Location::Cache&lt;&#x2F;code&gt;, &lt;code&gt;Location::Data&lt;&#x2F;code&gt;, and &lt;code&gt;Location::Config&lt;&#x2F;code&gt;), the application name, and a string which identifies the name of the data chunk. The value is anything that implements &lt;code&gt;Serialize&lt;&#x2F;code&gt; from &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;serde&quot;&gt;&lt;code&gt;serde&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Cache&lt;&#x2F;code&gt; is for data that can be cleared between runs of your application; &lt;code&gt;Data&lt;&#x2F;code&gt; is for blobs like save states, and &lt;code&gt;Config&lt;&#x2F;code&gt; is for application settings. &lt;code&gt;gestalt&lt;&#x2F;code&gt; uses &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;dirs&quot;&gt;&lt;code&gt;dirs&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to ensure that it saves your data in the right place for each, regardless of your user&#x27;s operating system.&lt;&#x2F;p&gt;
&lt;p&gt;That&#x27;s Day 3 done: &lt;code&gt;gestalt&lt;&#x2F;code&gt; is pretty small! Tomorrow&#x27;s library, &lt;code&gt;blinds&lt;&#x2F;code&gt;, starts to get quite a bit bigger.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019&quot;&gt;The introduction post&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-2&quot;&gt;&lt;code&gt;platter&lt;&#x2F;code&gt;: An async file-loading API for desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;This post!&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-4&quot;&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt;: An easy-to-use async wrapper of &lt;code&gt;winit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-5&quot;&gt;&lt;code&gt;golem&lt;&#x2F;code&gt;: An opinionated mostly-safe graphics library for desktop and web GL&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-day-6&quot;&gt;Changes to the Quicksilver application lifecycle&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-7&quot;&gt;Changes to the Quicksilver graphics API&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-8&quot;&gt;An overview of the work on web support this year&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Quicksilver Chanukah, Day 2: Platter</title>
		<published>2019-12-23T00:00:00+00:00</published>
		<updated>2019-12-23T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-2/" type="text/html"/>
		<id>https://ryanisaacg.com/code/quicksilver-chanukah-2019-day-2/</id>
		<content type="html">&lt;p&gt;This year saw the release of &lt;code&gt;async&#x2F;.await&lt;&#x2F;code&gt; in stable Rust, marking a huge change in how asynchronous code is written. Previously, one would have to chain a series of combinators onto a &lt;code&gt;Future&lt;&#x2F;code&gt; instance to accomplish asyncrhonous tasks. In Quicksilver, this was used for asset loading (for compatibility with the web backend), and has been a frequent source of pain.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Something as simple as loading a file, reading its contents, and loading a series of images based on those contents might look like this psuedo-Rust:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let images = load_file(&amp;quot;my_manifest_path&amp;quot;)
    .map(parse_file_contents)
    .and_then(|image_paths| join_all(
        image_paths
            .map(load_file)
            .map(|file| file.and_then(parse_image))
    );

render_loading();
loop {
    &amp;#x2F;&amp;#x2F; Core application loop
    if images.is_ready {
        render_frame(&amp;amp;images);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is fairly hard to read, and requires a bit of domain-specific knowledge of the combinators to achieve it. Worse still is introducing more than one of these combinator chains, and trying to execute game logic only if they complete. This snippet is plenty complex, and hasn&#x27;t even touched error handling.&lt;&#x2F;p&gt;
&lt;p&gt;Introducing &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;platter&quot;&gt;&lt;code&gt;platter&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, a new async-enabled crate with a single, simple task: load files on desktop and web with an easy API.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;render_loading();
let contents = load_file(&amp;quot;my_manifest_path&amp;quot;).await?;
let image_paths = parse_file_contents(contents);
let images = Vec::new();
for image_path in image_paths {
    let image_file = load_file(image_path).await?;
    images.push(parse_image(image_file)?);
}
loop {
    render_frame(&amp;amp;images);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can still make use of the combinators in a more functional-programming style if we wish, but now it&#x27;s much clearer:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;render_loading();
let contents = load_file(&amp;quot;my_manifest_path&amp;quot;).await;
let image_futures = parse_file_contents(contents)
    .map(load_file);
let images: Vec&amp;lt;Image&amp;gt; = try_join_all(image_futures)
    .await?
    .map(parse_image)
    .collect()?;
loop {
    render_frame(&amp;amp;images);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;platter&lt;&#x2F;code&gt; is small and can be plugged into your own game framework or game project if you want to harness &lt;code&gt;async&#x2F;await&lt;&#x2F;code&gt; to load files on desktop and web. It will be a major part of the new Quicksilver application lifecyle!&lt;&#x2F;p&gt;
&lt;p&gt;That&#x27;s Day 2 down, but there are 6 more days of Quicksilver Chanukah:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019&quot;&gt;Yesterday&#x27;s introduction post&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;This post!&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-3&quot;&gt;&lt;code&gt;gestalt&lt;&#x2F;code&gt;: An API to manage bundling and saving data locally on desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-4&quot;&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt;: An easy-to-use async wrapper of &lt;code&gt;winit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-5&quot;&gt;&lt;code&gt;golem&lt;&#x2F;code&gt;: An opinionated mostly-safe graphics library for desktop and web GL&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-day-6&quot;&gt;Changes to the Quicksilver application lifecycle&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-7&quot;&gt;Changes to the Quicksilver graphics API&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-8&quot;&gt;An overview of the work on web support this year&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>A Quicksilver Chanukah: Day 1</title>
		<published>2019-12-22T00:00:00+00:00</published>
		<updated>2019-12-22T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/quicksilver-chanukah-2019/" type="text/html"/>
		<id>https://ryanisaacg.com/code/quicksilver-chanukah-2019/</id>
		<content type="html">&lt;p&gt;I started this year with a &lt;a href=&quot;..&#x2F;state-of-quicksilver-feb-2019&quot;&gt;blog post about the state of Quicksilver&lt;&#x2F;a&gt; where I set a goal for myself: get web support for important game development crates upstreamed. At the end of the year, I&#x27;m happy to update this work (by me and many others!) has been a success, and the core of Rust&#x27;s game ecosystem is now-web enabled. In the future, I want to write a brief overview of those changes, but for now I want to focus on their relevance to Quicksilver.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Without having to maintain my own set of web bindings for Quicksilver, I was able to start working on significant changes to both the internal and external structure. There are a few entirely unrelated modules in Quicksilver that are all needed for the framework: handling filesystem resources, creating and loading local data, the event loop, the graphics API, and the sound API. It makes sense to allow users to pick and choose these systems, which is the goal of Quicksilver&#x27;s optional features. However, that still requires depending on Quicksilver, which doesn&#x27;t make sense for some projects. Instead, I&#x27;ve created a few new crates that anyone can drop into their project without pulling in any other Quicksilver-related code.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, a major new Rust feature landed this year: async&#x2F;await. Quicksilver&#x27;s asset loading system has been a sticking point, because of its design decisions and the inherent pain of combinator-based &lt;code&gt;Future&lt;&#x2F;code&gt; code. With &lt;code&gt;async&lt;&#x2F;code&gt; and &lt;code&gt;.await&lt;&#x2F;code&gt;, a new asynchronous asset loading API can be almost seamless. Combined with fixes to long-standing graphics API problems, I&#x27;ve been working on a new major release for Quicksilver (which will be the first breaking change in over a year.)&lt;&#x2F;p&gt;
&lt;p&gt;As &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hanukkah&quot;&gt;Chanukah&lt;&#x2F;a&gt; starts tonight, I&#x27;m going to share these new crates and big Quicksilver updates over the next eight days. I can&#x27;t promise I&#x27;ll actually stick to this schedule, but my goal is:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;This post!&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-2&quot;&gt;&lt;code&gt;platter&lt;&#x2F;code&gt;: An async file-loading API for desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-3&quot;&gt;&lt;code&gt;gestalt&lt;&#x2F;code&gt;: An API to manage bundling and saving data locally on desktop and web&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-4&quot;&gt;&lt;code&gt;blinds&lt;&#x2F;code&gt;: An easy-to-use async wrapper of &lt;code&gt;winit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-5&quot;&gt;&lt;code&gt;golem&lt;&#x2F;code&gt;: An opinionated mostly-safe graphics library for desktop and web GL&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-day-6&quot;&gt;Changes to the Quicksilver application lifecycle&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-7&quot;&gt;Changes to the Quicksilver graphics API&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;..&#x2F;quicksilver-chanukah-2019-day-8&quot;&gt;An overview of the work on web support this year&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Website Makeover</title>
		<published>2019-07-20T00:00:00+00:00</published>
		<updated>2019-07-20T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/new-blog-debut/" type="text/html"/>
		<id>https://ryanisaacg.com/code/new-blog-debut/</id>
		<content type="html">&lt;p&gt;So www.ryanisaacg.com has a very new look, powered by Hugo and my (fairly small) fork of the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rhazdon&#x2F;hugo-theme-hello-friend-ng&quot;&gt;hello-friend-ng&lt;&#x2F;a&gt; theme.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Partly the site will be dedicated to a bit of a professional showcase &#x2F; bio for myself, but also with added blog functionality I can communicate in a more public way about my plans for my open source projects.&lt;&#x2F;p&gt;
&lt;p&gt;The State of Quicksilver that I wrote earlier this year has moved from its previous home as Github gist to retroactively being a post here, as I feel more comfortable linking to my writing in a domain that I control and can ensure the links stay live. The Quicksilver website itself is still hosted within the Quicksilver repo, partially for ease of version control (if a commit changes code, it can change the website docs in lockstep) and partially because I&#x27;m not sure how much I want to present Quicksilver as being &lt;em&gt;my project&lt;&#x2F;em&gt; versus the &lt;em&gt;Quicksilver project&lt;&#x2F;em&gt;. I&#x27;m too cheap and lazy to buy a quicksilver domain, so the URL still contains my screen name, but the website is independent of the rest of ryanisaacg.com. Future State-Of-Quicksilver posts will also live on this blog though, as my personal plans for the project and my work for the Rust ecosystem feel out-of-band for the actual Quicksilver site.&lt;&#x2F;p&gt;
&lt;p&gt;I won&#x27;t be embedding Disqus for comments, but if you want to chat I&#x27;m on the &lt;a href=&quot;https:&#x2F;&#x2F;bit.ly&#x2F;rust-community&quot;&gt;Rust Community Discord&lt;&#x2F;a&gt; as @ryanisaacg. I&#x27;d love to hear people&#x27;s thoughts on the new look, if Quicksilver should be moved to a sub-page of this site, and if State of Quicksilver should be a gist, blog posts here, or some combination.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>The State of Quicksilver Feb 2019</title>
		<published>2019-02-04T00:00:00+00:00</published>
		<updated>2019-02-04T00:00:00+00:00</updated>
		<link href="https://ryanisaacg.com/code/state-of-quicksilver-feb-2019/" type="text/html"/>
		<id>https://ryanisaacg.com/code/state-of-quicksilver-feb-2019/</id>
		<content type="html">&lt;p&gt;For anyone who doesn&#x27;t know, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ryanisaacg&#x2F;quicksilver&quot;&gt;Quicksilver&lt;&#x2F;a&gt; is my 2D game framework that targets desktop and web. It is a pure-Rust library that focuses on ergonomics and simplicity.&lt;&#x2F;p&gt;
&lt;p&gt;Quicksilver is part of a small (but growing) set of Rust game engines. Notable are the Amethyst project, an open-source game engine, and ggez, a LOVE-inspired 2D game framework.
Increasingly it is practical to build an entire game with only the Rust toolchain: winit provides windowing, a variety of crates allow access to platform graphics APIs, rodio provides sound, rusttype for font rendering, etc. A pure-Rust game framework is getting easier to make all the time.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;However, very few libraries support WASM out of the box. This means Quicksilver and Rust WASM games in general essentially have small implementations of windowing, event handling, sounds, graphics, and input for the web that have not been contributed upstream.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-framework-problem&quot;&gt;The Framework Problem&lt;&#x2F;h2&gt;
&lt;p&gt;Opting to use Quicksilver for some feature (web support, API design, automatic batching) requires opting into &lt;em&gt;all&lt;&#x2F;em&gt; of Quicksilver&#x27;s features. This isn&#x27;t necessarily great! Even with compile-time feature flags available, it&#x27;s hard to do any Quicksilver code without buying into the State trait. This boils down to the vision of Quicksilver as a framework: if you can just plug in Quicksilver and start making a game right away, it needs to be everything to everyone.&lt;&#x2F;p&gt;
&lt;p&gt;Partly this is due to Quicksilver&#x27;s history as a bit of a learning project for me, which I wanted to build from scratch in as many places as possible. It&#x27;s also caused by my impatience: the Rust ecosystem is amazing and featureful, but waiting for every single upstream project to accept changes would mean that Quicksilver could only be developed as fast as its slowest dependency. I tend to have time to work on the project in bursts, when I clear out the bug backlog and implement a few features from the roadmap; this doesn&#x27;t mesh well with long-running interactions with other projects. The way I&#x27;ve handled this in the past is writing my own Javascript bindings for each feature, essentially cloning an entire crate.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-fundamentals&quot;&gt;The Fundamentals&lt;&#x2F;h2&gt;
&lt;p&gt;Largely, Quicksilver&#x27;s API is approaching a state of stability. It accomplishes most of what I want it to, in a way I&#x27;m largely satisfied with. For end users, the Quicksilver project has been more or less stable for a few months, and no substantial breaking changes are planned for the future.&lt;&#x2F;p&gt;
&lt;p&gt;However, Quicksilver still has quite a few systems implemented by a dependency and an ad-hoc web clone of that dependency. This is what I hope to change, by contributing web backends across the ecosystem. My ideal outcome is that the fundamental multimedia crates (winit, rodio, gilrs, etc.) can run on WASM out-of-the-box.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;going-forward&quot;&gt;Going Forward&lt;&#x2F;h2&gt;
&lt;p&gt;If it sounds like my current goal is to make Quicksilver obsolete, that wouldn&#x27;t be too far off. Quicksilver&#x27;s raison d&#x27;etre is packaging up a bundle of functionality and to provide a single API for both web and native. Moving the ecosystem to support web and native makes this less important. Parts of Quicksilver that I think are particularly useful will probably become their own crates (re-exported in Quicksilver) to allow their use outside the framework. Some future version of Quicksilver may just be entirely a re-export of various crates and types with a consistent organization.&lt;&#x2F;p&gt;
&lt;p&gt;In essence, I want seamless desktop and WASM development to move from a selling point of developing games in Quicksilver to a selling point of developing games in Rust.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
