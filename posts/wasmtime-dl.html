<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="/post.css">
    
    <link rel="alternate" type="application/atom+xml" href="/feed.xml" title="RSS feed">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title> High Crimes and Misdemeanors with WASM and Dynamic Linking </title>
<meta property="og:title" content="High Crimes and Misdemeanors with WASM and Dynamic Linking">

<meta name="description" content="In my programming language, currently codenamed Brick, I want to allow developers to pull in platform-native libraries written in other languages. Brick compiles to WebAssembly (wasm), and wasm is totally sandboxed by design. Without functions provided by the environment (“imports” in wasm lingo), a wasm module can have no side effects when run. I want Brick programs to have plenty of side effects, like making web requests or drawing graphics to the screen. How can we provide these side effects to our wasm code?">
<meta property="og:description" content="In my programming language, currently codenamed Brick, I want to allow developers to pull in platform-native libraries written in other languages. Brick compiles to WebAssembly (wasm), and wasm is totally sandboxed by design. Without functions provided by the environment (“imports” in wasm lingo), a wasm module can have no side effects when run. I want Brick programs to have plenty of side effects, like making web requests or drawing graphics to the screen. How can we provide these side effects to our wasm code?">

<meta name="theme-color" content="#7d7fff">


  </head>
  <body>
    <header>
        <div class="page-header">
        
            <strong>ryan.isaac.g</strong>
        
        <div class="header-links">
            <a href="/">/home</a>
            <a href="/posts">/all posts</a>
        </div>
    </div>

      
        <aside>
          <p>
            This post is a draft. Please don't share it with anyone else; if I didn't send you the link directly, you're probably not supposed to be seeing it!
          </p>
        </aside>
      
      <h1> High Crimes and Misdemeanors with WASM and Dynamic Linking </h1>
      <small>
        16 Aug  2024
      </small>
    </header>
    <article>
      <p>In <a href="programming-language-for-fun">my programming language</a>, currently codenamed Brick, I want to allow developers to pull in platform-native libraries written in other languages. Brick compiles to WebAssembly (wasm), and wasm is totally sandboxed by design. Without functions provided by the environment (“imports” in wasm lingo), a wasm module can have no side effects when run. I want Brick programs to have plenty of side effects, like making web requests or drawing graphics to the screen. How can we provide these side effects to our wasm code?</p>
<p>On desktop I’m running Brick programs via <a href="https://github.com/bytecodealliance/wasmtime"><code>wasmtime</code></a>, a wasm runtime maintained by the folks behind the wasm spec. It’s written in Rust and exposes a Rust API, which allows us to attach Rust functions as a wasm module’s imports. This is great, because it allows us to include external libraries like <code>tokio</code> for web requests or <code>macroquad</code> for graphics. The only problem is that each of these bindings need to be written by hand in our Rust program. There’s no way to introduce new bindings at runtime, which makes it hard for Brick packages to use any external code I didn’t plan for. What if we link our wasm binary directly with a library instead?</p>
<aside>
<p><strong>What is linking?</strong> Linking is the process by which different binary objects form one application on an operating system. There are two types of linking: dynamic and static. Dynamic linking means that our application knows what libraries it needs to run, and functions it needs from those libraries, but it doesn’t store those functions directly. Instead the program asks the operating system for the library each time it runs<sup class="footnote-ref"><a href="#fn1" id="fnref1" aria-describedby="footnotes-label" role="doc-noteref">[1]</a></sup>. Static linking bundles a library’s contents directly into the binary, and is favored by Rust and Go. It allows the final result to be easily portable.</p>
</aside>
<h2>High Crime: Break down the sandbox</h2>
<p>Enter <code>wasmtime-dl</code>, a very bad idea I had. My goal was to break a hole in the side of the sandbox, and allow Brick packages to link to arbitrary dynamic libraries. The first design I sketched out was simple. Given a set of function definitions, link the dynamic library with wasmtime. There was just one problem: I just had no idea how to accomplish it. But I’m in batch at the Recurse Center, so that’s no excuse for backing down.</p>
<p>When approaching something that I’m not sure how to do, I always try to tackle the riskiest part first. Risk is subjective at this phase; risk factors include “is this possible?” or “will this be prohibitively difficult?” or “will something make me change my mind?” Often this saves me a lot of grief down the road. On this project there seemed to be three main parts: reading some external function description, creating a wasmtime binding, and linking to a dynamic library. Only the third seemed high-risk, so I started there.</p>
<p>A long time ago, I wrote games in C. I remembered trying and failing to set up hot reloading for the games, so I could recompile them without having to relaunch the game. In those explorations I encountered the <code>dlopen</code> Linux system call, which allows you to load dynamic libraries at runtime. I searched “<code>dlopen</code> Rust”, which was a good-enough starting point. I found a few crates that all did roughly the same thing: open a dynamic library, and return a function pointer for a given symbol name in that library. So now we can definitely take a dynamic library and starting pulling functions out of it.</p>
<h2>High Crime: 1 million lines of Rust</h2>
<p>Here I encountered my first major obstacle. I need to tell Rust what the type of the function pointer is before I can call it. I don’t even think this is a safety concern; how can the compiler emit code if it doesn’t know what values will be sent into the function call? Unfortunately I don’t know the type at compile time; I’ll be reading the types in at runtime.</p>
<p>I decided to solve my problem with a little code generation. By creating a very big match statement, I could dynamically pick the right type based on the runtime information. If the function definition was <code>(f32, f64, i32, f32)</code> then I would match that tuple, and that match branch would create a function pointer with type <code>fn(f32, f64, i32, f32)</code>. Type problems solved! I wrote a quick Python program to generate my match statements and hit run.</p>
<p>After it ran for a few seconds I started to get suspicious. “Why is it taking so long?”, I thought. I had tried to generate up to 16 arguments (which seems like a reasonable number of arguments to me), with an optional return value. In wasm, types may be 32 or 64 bit and they may be integers or floats, giving us four types: <code>i32</code>, <code>f32</code>, <code>i64</code>, and <code>f64</code>. Surely the number of combinations couldn’t be that great! I punched it into Wolfram Alpha just to double check and almost fell out of my chair: 4 parameter types and one optional return type, for every parameter length up to 16, gives over one million combinations.</p>
<p>Numbers! How could you do this to me??? Let alone the time to generate 3 million lines of Rust, imagine the time to compile it. Forget office fencing, you’ll have time to run a whole office LARP!</p>
<p><img src="https://imgs.xkcd.com/comics/compiling.png" alt="XKCD comic strip. two stick figures fence on office rolling chairs while waiting for their code to compile"></p>
<p>I scoped my ambitions way down and generated only up to 6 parameters instead, which is still a CPU-crushing 11,000 cases. I had my first working prototype, even if it took minutes to compile!</p>
<h2>Misdemeanor: Why define the bindings?</h2>
<p>You shouldn’t have to define the bindings - they’re right there in the binary! I’m not sure if I realized this in the shower, or on the train, or at the gym, but it hit me like a bolt of lightning. A wasm binary defines the types of its imports, including what parameters and return values functions have. That means we can skip a step in the previous version. Instead of having some external definition for each function, we’ll just use the one provided by the wasm binary.</p>
<p>I pulled in the <a href="https://crates.io/crates/wasmparser"><code>wasmparser</code></a> crate and got to work. The first experimental version worked! Driving the function bindings by examining the imports of the module itself meant that the user only needed to provide a mapping from wasm imports to dynamic libraries, and <code>wasmtime-dl</code> could drive the rest.</p>
<p>It was only after I had done the work that I realized it was fatally flawed. In wasm, pointers are represented as <code>i32</code> values. They serve as offsets into wasm’s linear memory segment. The wasm binary format provides no distinction between a regular int and one that is used as a pointer, but that distinction matters a lot to our binding program. Before we can pass the pointer to an external library, we need to add the offset where the wasm VM’s memory starts. Within wasm a pointer might look like  the value <code>12</code>, but outside it will look like more like <code>0x0ffac12</code>.</p>
<p>We <em>could</em> just have annotations for which parameters and return values of foreign functions expect pointers, but what’s the point<sup class="footnote-ref"><a href="#fn2" id="fnref2" aria-describedby="footnotes-label" role="doc-noteref">[2]</a></sup>? Once we need annotations on many functions, we may as well accept the need for annotations on every function. I added a new type to <code>wasmtime-dl</code> that represents pointers; it takes an <code>i32</code> on the wasm side and hands a correct virtual memory pointer to the dynamic library.</p>
<aside>
<p>Technically <code>wasmtime-dl</code> doesn’t support 32-bit systems, because it assumes the host pointer is a 64 bit int. In practice… basically all desktop computers are 64 bits nowadays, right?</p>
</aside>
<h2>Misdemeanor: Floats and ints… they’re all just bytes, right?</h2>
<p>At this point I had another good? bad? idea. To cut down on the combinatorial explosion, what if I pretended that all float parameters are ints? An <code>f32</code> or an <code>i32</code> are both 32-bit chunks of data; the only difference between them is how you interpret those 32 bits. By treating all parameters to the dynamic library functions as <code>i32</code> or <code>i64</code> we can drastically cut down on the number of generated match cases.</p>
<p>This required some finagling. First, instead of getting to use the convenient type-safe methods on wasmtime’s <code>Linker</code>, I had to drop down into the less-convenient, less-safe, and slower “raw” binding mode. Second, I discovered that punning an <code>f32</code> into an <code>i32</code> was a little more complicated than I initially expected. After a few iterations where the bindings produced total gibberish, I ended up with a pretty simple use of the <a href="https://crates.io/crates/bytemuck"><code>bytemuck</code></a> crate to transmute the provided f32 bytes into an i32.</p>
<p>By constraining the combinatorial space, I managed to fit in up to eight parameters in the generated code. It still takes minutes to compile though, even on an M1 Mac, so it’s not exactly lightweight.</p>
<h2>A snag: structs</h2>
<p>I was excited to have created this horrible beast. To make a little demo I decided to pull in <a href="https://www.raylib.com/index.html"><code>raylib</code></a>, a simple C library for creating games. As I scrolled through the raylib API, it hit me: wasm doesn’t know about structs. Any C function that takes a struct or union will expect it to conform to the C calling ABI; wasm only knows about its core primitive types. As it stands there’s no way to call a function that expects a non-primitive argument.</p>
<p>This problem isn’t technically insurmountable, but it feels that way in a practical sense. I’m sure I could add an elaborate layer to marshal wasm parameters into structs, but that would explode my combination issue even further.</p>
<h2>Verdict</h2>
<p>My initial goal (bind from wasm imports to dynamic libraries) has been achieved (with some criminal mischief along the way). It’s not a practical end product, but I learned a lot about dynamic linking and the limits of code generation! You can check out the <a href="https://github.com/ryanisaacg/wasmtime-dl/"><code>wasmtime-dl</code> repo</a> to see where I ended up, and you can pull in the crate if you want to be a victim of a compile-time crime.</p>
<p>This approach isn’t going to pan out for Brick. Instead I’m going to experiment with an idea I’ve only seen in <a href="https://www.roc-lang.org/">Roc</a>: the language requires an external program called a “platform” to run. The core language remains the same, but the IO primitives and runtime characteristics are determined by the platform. Considering the sandboxed model of wasm, this seems like a great fit for Brick; stay tuned for a possible future post on the subject.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>I have no idea how this process works! I’m also not sure how much it varies by operating system. I know that all the major operating systems have their own dynamic library formats (<code>dll</code> on Windows, <code>dylib</code> on macOS, and <code>so</code> on Linux), and that the OS searches various locations for a library when loading a library. <a href="#fnref1" aria-label="Back to reference 1" role="doc-backlink" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Pun intended. <a href="#fnref2" aria-label="Back to reference 2" role="doc-backlink" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </article>
  </body>
</html>
