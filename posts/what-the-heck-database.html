<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="/post.css">
    
    <link rel="alternate" type="application/atom+xml" href="/feed.xml" title="RSS feed">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title> What the Heck is a Database </title>
<meta property="og:title" content="What the Heck is a Database">

<meta name="description" content="">
<meta property="og:description" content="">

<meta name="theme-color" content="#E7CD78">


  </head>
  <body>
    <header>
        <div class="page-header">
        
            <strong>ryan.isaac.g</strong>
        
        <div class="header-links">
            <a href="/">/home</a>
        </div>
    </div>

      
        <aside>
          <p>
            This post is a draft. Please don't share it with anyone else; if I didn't send you the link directly, you're probably not supposed to be seeing it!
          </p>
        </aside>
      
      <h1> What the Heck is a Database </h1>
      <small>
        23 Jul  2024
      </small>
    </header>
    <article>
      <ul>
<li>Only know about K/V stores and how SQL relates
<ul>
<li>Are document databases built on K/V stores? what would the key be?</li>
</ul>
</li>
<li>Write-ahead log</li>
<li>K/V built on a B+Tree
<ul>
<li>important for atomicity / durability</li>
</ul>
</li>
<li>A SQL table is a K/V store with specific columnar Vs
<ul>
<li>how does a table with multiple primary keys work</li>
</ul>
</li>
</ul>
<p>Starting my batch at the Recurse Center, I knew one of the things I wanted to learn was the basics of database internals. I can sling SQL as well as your average full-stack engineer, but what happens under the hood was a total mystery to me. It’s a magic spell, And I hate magic!</p>
<p>I started with TODO. By working through the first half of the book in Rust, I learned:</p>
<ul>
<li>“Logs” in database means something pretty different from what I’m used to. Instead of storing information about a program’s operation history, a “write ahead log” is a data structure you can safely append incoming operations to. This allows concurrent operations to be safely stored in a durable fashion, even if the process crashes mid-write.</li>
<li>To build a persistent key/value store, it’s important to use a data structure where changes are atomic (again to be resilient to crashes mid-write). There are LSM-trees; all I know about them is that the acronym expands to Log-Structured Merge. There are also B+Trees, which I’ve gotten up close and personal with.</li>
<li>For efficient manipulation of files on disk, it’s important to keep in mind TODO {sectors, segments}. The smallest possible disk read is often a few kilobytes; reading less than that at a time is inefficient IO. Memory-mapping is the best approach if you need random access to disk</li>
</ul>
<p>I also built a memory-mapped B+Tree in Rust to make sure I understood the concepts. I think it doesn’t fully rebalance itself (making it somewhat inefficient), but it does correctly handle get/insert/remove operations.</p>
<p>In week 2 I joined some of my batchmates in writing SQLite from scratch. I decided to go about this in Zig, to stretch my legs and learn a new language. The first step is to parse the database file’s header, which is pretty simple. Things immediately kick up a notch on the next step as I began to dig into SQLite’s internal structures.</p>
<p>Each SQLite database is represented by a page (4096 bytes in the test database, but it can be configured on a per-DB basis). A page is also a node in a B+Tree, either a leaf or branch; trees either represent tables or indices. Each page consists of a header, an array of internal pointers to “cells”, and then the cells themselves.</p>
<p>TODO: talk about endian-ness bugs
TODO: talk about first page cell offsets</p>

    </article>
  </body>
</html>
