<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on ryan.isaac.g</title>
        <link>https://www.ryanisaacg.com/posts/</link>
        <description>Recent content in Posts on ryan.isaac.g</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Thu, 26 Dec 2019 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://www.ryanisaacg.com/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>A Quicksilver Chanukah, Day 5: Golem</title>
            <link>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019-day-5/</link>
            <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019-day-5/</guid>
            <description>What is golem? golem is a mostly-safe graphics API that targets OpenGL 3.2 and WebGL 1 that helps make writing GL less painful
Why golem and not X If you&amp;rsquo;re just interested in what golem is and how it works, feel free to skip this section!
The previous three days I&amp;rsquo;ve introduced new crates that mostly stood on their own. I&amp;rsquo;m not aware of any fleshed-out alternatives, so creating those libraries myself doesn&amp;rsquo;t require much explanation.</description>
            <content type="html"><![CDATA[

<h2 id="what-is-golem">What is <code>golem</code>?</h2>

<p><code>golem</code> is a mostly-safe graphics API that targets OpenGL 3.2 and WebGL 1 that helps make writing GL less painful</p>

<h2 id="why-golem-and-not-x">Why <code>golem</code> and not X</h2>

<p>If you&rsquo;re just interested in what <code>golem</code> is and how it works, feel free to skip this section!</p>

<p>The previous three days I&rsquo;ve introduced new crates that mostly stood on their own. I&rsquo;m not aware of any fleshed-out alternatives, so creating those libraries myself doesn&rsquo;t require much explanation. <code>golem</code>, however, is a different story: there aren&rsquo;t exactly a shortage of Rust graphics libraries. There are a variety of reasons as to why none of them fit Quicksilver&rsquo;s needs, most of which revolve around support for older hardware or older APIs. For brevity, I&rsquo;d recommend you check out <a href="https://wiki.alopex.li/AGuideToRustGraphicsLibraries2019">icefox&rsquo;s guide to the existing graphics options</a>.</p>

<p>I have a test device that I think is a good benchmark for something Quicksilver-powered games should be able to target, and it doesn&rsquo;t support Vulkan. This eliminates <code>ash</code> and <code>vulkano</code> straight off the bat, and <code>gfx-hal</code> as well. <code>ash</code> and <code>vulkano</code> target Vulkan directly, and <code>gfx-hal</code>&rsquo;s OpenGL backend is not currently reliable enough (though I hope to see that improve!)</p>

<p>I also want to be able to support WebGL 1, but WebGL 1 is not a very modern version of OpenGL. This makes it, for good reaon, unattractive to other libraries (like <code>luminance</code>, which is targeting WebGL 2 in its upcoming web support). However, WebGL 2&rsquo;s <a href="https://caniuse.com/#feat=webgl2">market share</a> still hovers at around 75%, which isn&rsquo;t ideal; notably missing from WebGL 2 support are the current verisons of Edge, Safari, and iOS Safari. Quicksilver recently transitioned to using WebGL 1 for better platform support, and I didn&rsquo;t want to regress by requiring a high version. This rules out <code>luminance</code>, and presumably <code>glium</code> (which has no current development towards web support as far as I&rsquo;m aware.)</p>

<p>With just those two constraints I&rsquo;m out of options, so I decided to write <code>golem</code>.</p>

<h2 id="mostly-safe">Mostly-Safe?</h2>

<p>Where possible, <code>golem</code> handles for you the complex state machine of OpenGL. In other places, it prevents you from using resources that haven&rsquo;t been properly set-up. In these cases, <code>golem</code> is safe with low-overhead, removing footguns from OpenGL without slowing your code down. In others, more overhead would be required to keep the API free of <code>unsafe</code>. Currently only two functions are marked as <code>unsafe</code> in <code>golem</code>&rsquo;s public API, but they are the only functions that draw things to the screen! This means using <code>unsafe</code> code as a consumer of <code>golem</code> is unavoidable, hence &ldquo;mostly-safe.&rdquo;</p>

<h2 id="a-code-snippet">A Code Snippet</h2>

<p>Hopefull if you&rsquo;re familiar with graphics APIs, this code snippet to draw a triangle to the screen will look a little familiar. If not, the comments should help you follow along!</p>

<pre><code class="language-rust">use blinds::*;
use golem::{
    Attribute, AttributeType, Context,
    Dimension::{D2, D4},
    ElementBuffer, GeometryMode, GolemError, ShaderDescription, ShaderProgram, VertexBuffer,
};

// The application loop, powered by the blinds crate
async fn app(
    window: Window,
    ctx: glow::Context,
    mut events: EventStream,
) -&gt; Result&lt;(), GolemError&gt; {
    // Create a context from 'glow', GL On Whatever
    let ctx = &amp;Context::from_glow(ctx)?;

    #[rustfmt::skip]
    // This is the data that represents the triangle
    // It's arranged how it will be passed to the GPU: each position represented as two f32 values,
    // followed by each color represented as 4 f32 values. The positions are on a scale from -1.0
    // to 1.0, which represents the viewport in OpenGL. The colors are represented as R, G, B, A,
    // on a scale from 0.0 to 1.0
    let vertices = [
        // Position         Color
        -0.5, -0.5,         1.0, 0.0, 0.0, 1.0,
        0.5, -0.5,          0.0, 1.0, 0.0, 1.0,
        0.0, 0.5,           0.0, 0.0, 1.0, 1.0
    ];
    // This is the data that indicates how to draw the vertices
    // For a simple example of one triangle, we don't gain much from this. Any order of these three
    // points will give us the same triangle. However, if we add more points (to draw a square, for
    // example), then we can write each point once while using it in multiple triangles.
    let indices = [0, 1, 2];

    // Here we create the ShaderProgram, which is some code that runs on the GPU. It determines how
    // to turn our vertex data into an actual vertex that GL understands, and how to color each
    // 'fragment' (essentially a pixel). These are each their own little program, where the
    // information from the vertex shader is fed into the fragment shader.
    // For the purposes of making sure the shaders match, and for ensuring compatibility on desktop
    // and web, the inputs are represented as data structures and then converted to shader
    // declarations at runtime.
    // The input to the shader program is fed to the vertex_input, so your vertex data's format
    // needs to match what you define in vertex_input
    let mut shader = ShaderProgram::new(
        ctx,
        ShaderDescription {
            // Take in to the shader a position (as a vector with 2 components) and a color (as a
            // vector with 4 components). This is the same format as 'vertices' above
            vertex_input: &amp;[
                Attribute::new(&quot;vert_position&quot;, AttributeType::Vector(D2)),
                Attribute::new(&quot;vert_color&quot;, AttributeType::Vector(D4)),
            ],
            // Pass to the fragment shader the color
            // OpenGL will actually smoothly interpolate between different vertex values for us, so
            // a red vertex and a blue vertex will have a gradient between them
            fragment_input: &amp;[Attribute::new(&quot;frag_color&quot;, AttributeType::Vector(D4))],
            // Uniforms represent a value that's the same for the entire shader; we don't need any
            // here. If you're rendering images or applying transformations to your entire draw
            // call, use uniforms!
            uniforms: &amp;[],
            // A program written in GLSL that uses the inputs and outputs defined above
            // There's also a hard-coded output called gl_Position
            vertex_shader: r#&quot; void main() {
            gl_Position = vec4(vert_position, 0, 1);
            frag_color = vert_color;
        }&quot;#,
            // The fragment shader has a hard-coded output: gl_FragColor
            fragment_shader: r#&quot; void main() {
            gl_FragColor = frag_color;
        }&quot;#,
        },
    )?;

    // Create buffer objects, which we use to transfer data from the CPU to the GPU
    let mut vb = VertexBuffer::new(ctx)?;
    let mut eb = ElementBuffer::new(ctx)?;
    // Set the data of the buffer to be our vertices and indices from earlier
    vb.set_data(&amp;vertices);
    eb.set_data(&amp;indices);
    // Prepare the shader for operations: shaders will raise errors if you forget to bind them
    shader.bind();
    // Clear the screen
    ctx.clear();
    unsafe {
        // Using our buffers, draw our triangle
        // We could also interpert our indices as Lines or a variety of other shape options:
        // nothing binds us to necessarily using Triangles, even though they're the most common
        // shape in graphics
        shader.draw(&amp;vb, &amp;eb, 0..indices.len(), GeometryMode::Triangles)?;
    }
    // Show our data to the window
    window.present();
    // Keep the window open and responsive until the user exits
    loop {
        events.next_event().await;
    }
}

// Run our application!
fn main() {
    run_gl(Settings::default(), |window, gfx, events| {
        async move { app(window, gfx, events).await.unwrap() }
    });
}
</code></pre>

<p>(This is also an example of <a href="../quicksilver-chanukah-2019-day-4">yesterday&rsquo;s <code>blinds</code></a> and its OpenGL support.)</p>

<h2 id="further-development">Further Development</h2>

<p><code>golem</code> is not intended to be a fully-featured wrapper around all of OpenGL. It&rsquo;s intended to be enough to write fairly complex 2D graphics, or fairly simple 3D graphics. That said, there is a lot that&rsquo;s missing! Some of it is documented on the <a href="https://github.com/ryanisaacg/golem/issues">issue tracker</a>, but I&rsquo;m sure that I&rsquo;ve missed other things. Nearly everything I need for Quicksilver is done, but your use case might be different. Feel free to open an issue discussing a feature addition, or try and experiment with a fork for larger changes.</p>

<p><code>golem</code> is the last new crate to announce, which means tomorrow is about what these crates enable: the new version of Quicksilver.</p>

<ol>
<li><a href="../quicksilver-chanukah-2019">The introduction post</a></li>
<li><a href="../quicksilver-chanukah-2019-day-2"><code>platter</code>: An async file-loading API for desktop and web</a></li>
<li><a href="../quicksilver-chanukah-2019-day-3"><code>gestalt</code>: An API to manage bundling and saving data locally on desktop and web</a></li>
<li><a href="../quicksilver-chanukah-2019-day-4"><code>blinds</code>: An easy-to-use async wrapper of <code>winit</code></a></li>
<li>This post!</li>
<li>Changes to the Quicksilver application lifecycle</li>
<li>Changes to the Quicskilver graphics API</li>
<li>An overview of the work on web support this year</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>A Quicksilver Chanukah, Day 4: Blinds</title>
            <link>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019-day-4/</link>
            <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019-day-4/</guid>
            <description>With the recent update to winit, it gained web support! This is great, and it means that Quicksilver doesn&amp;rsquo;t need to have its own parallel implementation of windowing. However, there is room for an abstraction that&amp;rsquo;s a little simpler than Winit, and takes advantage of async/.await, which is where blinds comes in.
blinds is based on winit, but focused on Quicksilver&amp;rsquo;s specific use case of single-window games on desktop and web.</description>
            <content type="html"><![CDATA[<p>With the recent update to <a href="https://github.com/rust-windowing/winit"><code>winit</code></a>, it gained web support! This is great, and it means that Quicksilver doesn&rsquo;t need to have its own parallel implementation of windowing. However, there is room for an abstraction that&rsquo;s a little simpler than Winit, and takes advantage of <code>async/.await</code>, which is where <a href="https://crates.io/crates/blinds"><code>blinds</code></a> comes in.</p>

<p><code>blinds</code> is based on <code>winit</code>, but focused on Quicksilver&rsquo;s specific use case of single-window games on desktop and web. It also integrates <code>gilrs</code> for gamepad support (though this could be provided directly by <code>winit</code> later), without exposing either in its external API. Additionally, <code>blinds</code> has optional support for OpenGL, via <code>glow</code> for uniform bindings across web and desktop.</p>

<p>The <code>async</code> API works via the <code>LocalPool</code> and the <code>winit</code> event loop, allowing you to write code that <em>almost</em> looks like a synchronous event loop.</p>

<pre><code class="language-rust">use blinds::{run, Event, EventStream, Key, Settings, Window};

run(Settings::default(), app);

async fn app(_window: Window, mut events: EventStream) {
    loop {
        while let Some(ev) = events.next_event().await {
            // Process your events here!
        }
        // Process your frame here!
    }
}
</code></pre>

<p>The use of <code>.await</code> here is a bit of a hack, as it allows the event loop to wrest control away from the user and return it to the browser without blocking. Compare this to the comparable snippet from the legacy Quicksilver API:</p>

<pre><code class="language-rust">use quicksilver::{
    Result,
    geom::Vector,
    lifecycle::{Event, Settings, State, Window, run},
};

struct HelloWorld;

impl State for HelloWorld {
    fn new() -&gt; Result&lt;HelloWorld&gt; {
        Ok(HelloWorld)
    }
    
    fn event(&amp;mut self, window: &amp;mut Window, event: &amp;Event) -&gt; Result&lt;()&gt; {
        // Process events here
        Ok(())
    }
    
    fn update(&amp;mut self, window: &amp;mut Window) -&gt; Result&lt;()&gt; {
        // Update here
        Ok(())
    }

    fn draw(&amp;mut self, window: &amp;mut Window) -&gt; Result&lt;()&gt; {
        // Draw here
        Ok(())
    }
}

fn main() {
    run::&lt;HelloWorld&gt;(&quot;Hello World&quot;, Vector::new(800, 600), Settings::default());
}
</code></pre>

<p>The <code>async</code> API isn&rsquo;t just way more convenient than the previous, trait-based system. It also allows you to use other <code>async</code> APIs (like <a href="../quicksilver-chanukah-2019-day-2">day 2&rsquo;s <code>platter</code></a>), which is important for web support.</p>

<p><code>blinds</code> isn&rsquo;t quite ready for a full release yet: there are a few more window APIs I do want to expose before it leaves alpha. However, you can still try it out, just be aware that the API is fairly unstable and likely to change between multiple times before the first non-alpha release!</p>

<p>With <code>blinds</code> today, tomorrow will be the last new crate: <code>golem</code>!</p>

<ol>
<li><a href="../quicksilver-chanukah-2019">The introduction post</a></li>
<li><a href="../quicksilver-chanukah-2019-day-2"><code>platter</code>: An async file-loading API for desktop and web</a></li>
<li><a href="../quicksilver-chanukah-2019-day-3"><code>gestalt</code>: An API to manage bundling and saving data locally on desktop and web</a></li>
<li>This post!</li>
<li><code>golem</code>: An opinionated mostly-safe graphics library for desktop and web GL</li>
<li>Changes to the Quicksilver application lifecycle</li>
<li>Changes to the Quicskilver graphics API</li>
<li>An overview of the work on web support this year</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>A Quicksilver Chanukah, Day 3: Gestalt</title>
            <link>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019-day-3/</link>
            <pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019-day-3/</guid>
            <description>Often your application might want to store gamestate or configurations, but the web has no filesystem access. Additionally, you don&amp;rsquo;t want to just dump files in the user&amp;rsquo;s home directory; each desktop operating system has a different preferred location for storing application-specific data, and often different locations for different kinds of data.
Introducing gestalt, a library that bundles up your data and stores it away so you don&amp;rsquo;t have to. A sample to save some game state:</description>
            <content type="html"><![CDATA[<p>Often your application might want to store gamestate or configurations, but the web has no filesystem access. Additionally, you don&rsquo;t want to just dump files in the user&rsquo;s home directory; each desktop operating system has a different preferred location for storing application-specific data, and often different locations for different kinds of data.</p>

<p>Introducing <a href="https://crates.io/crates/gestalt"><code>gestalt</code></a>, a library that bundles up your data and stores it away so you don&rsquo;t have to. A sample to save some game state:</p>

<pre><code class="language-rust">use gestalt::{Location, save, load};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Player {
    name: String,
    score: u32
}

let player1 = Player { name: &quot;Bob&quot;.to_string(), score: 21 };
save(Location::Cache, &quot;mygame&quot;, &quot;player1&quot;, &amp;player1).expect(&quot;Could not save Player 1&quot;);

let player2 = Player { name: &quot;Alice&quot;.to_string(), score: 200 };
save(Location::Cache, &quot;mygame&quot;, &quot;player2&quot;, &amp;player2).expect(&quot;Could not save Player 2&quot;);

// Now reload.
let player1 = load::&lt;Player&gt;(Location::Cache, &quot;mygame&quot;, &quot;player1&quot;).expect(&quot;Could not load Player 1&quot;);
let player2 = load::&lt;Player&gt;(Location::Cache, &quot;mygame&quot;, &quot;player2&quot;).expect(&quot;Could not load Player 2&quot;);
</code></pre>

<p>Getsalt creates a Key/Value store, backed by the filesystem on desktop and the web storage API. The key is formed by <code>Location</code>, which determines the kind of data (<code>Location::Cache</code>, <code>Location::Data</code>, and <code>Location::Config</code>), the application name, and a string which identifies the name of the data chunk. The value is anything that implements <code>Serialize</code> from <a href="https://crates.io/crates/serde"><code>serde</code></a>.</p>

<p><code>Cache</code> is for data that can be cleared between runs of your application; <code>Data</code> is for blobs like save states, and <code>Config</code> is for application settings. <code>gestalt</code> uses <a href="https://crates.io/crates/dirs"><code>dirs</code></a> to ensure that it saves your data in the right place for each, regardless of your user&rsquo;s operating system.</p>

<p>That&rsquo;s Day 3 done: <code>gestalt</code> is pretty small! Tomorrow&rsquo;s library, <code>blinds</code>, starts to get quite a bit bigger.</p>

<ol>
<li><a href="../quicksilver-chanukah-2019">The introduction post</a></li>
<li><a href="../quicksilver-chanukah-2019-day-2"><code>platter</code>: An async file-loading API for desktop and web</a></li>
<li>This post!</li>
<li><a href="../quicksilver-chanukah-2019-day-4"><code>blinds</code>: An easy-to-use async wrapper of <code>winit</code></a></li>
<li><code>golem</code>: An opinionated mostly-safe graphics library for desktop and web GL</li>
<li>Changes to the Quicksilver application lifecycle</li>
<li>Changes to the Quicskilver graphics API</li>
<li>An overview of the work on web support this yea5</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>A Quicksilver Chanukah, Day 2: Platter</title>
            <link>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019-day-2/</link>
            <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019-day-2/</guid>
            <description>This year saw the release of async/.await in stable Rust, marking a huge change in how asynchronous code is written. Previously, one would have to chain a series of combinators onto a Future instance to accomplish asyncrhonous tasks. In Quicksilver, this was used for asset loading (for compatibility with the web backend), and has been a frequent source of pain.
Something as simple as loading a file, reading its contents, and loading a series of images based on those contents might look like this psuedo-Rust:</description>
            <content type="html"><![CDATA[<p>This year saw the release of <code>async/.await</code> in stable Rust, marking a huge change in how asynchronous code is written. Previously, one would have to chain a series of combinators onto a <code>Future</code> instance to accomplish asyncrhonous tasks. In Quicksilver, this was used for asset loading (for compatibility with the web backend), and has been a frequent source of pain.</p>

<p>Something as simple as loading a file, reading its contents, and loading a series of images based on those contents might look like this psuedo-Rust:</p>

<pre><code class="language-rust">let images = load_file(&quot;my_manifest_path&quot;)
    .map(parse_file_contents)
    .and_then(|image_paths| join_all(
        image_paths
            .map(load_file)
            .map(|file| file.and_then(parse_image))
    );

render_loading();
loop {
    // Core application loop
    if images.is_ready {
        render_frame(&amp;images);
    }
}
</code></pre>

<p>This is fairly hard to read, and requires a bit of domain-specific knowledge of the combinators to achieve it. Worse still is introducing more than one of these combinator chains, and trying to execute game logic only if they complete. This snippet is plenty complex, and hasn&rsquo;t even touched error handling.</p>

<p>Introducing <a href="https://crates.io/crates/platter"><code>platter</code></a>, a new async-enabled crate with a single, simple task: load files on desktop and web with an easy API.</p>

<pre><code class="language-rust">render_loading();
let contents = load_file(&quot;my_manifest_path&quot;).await?;
let image_paths = parse_file_contents(contents);
let images = Vec::new();
for image_path in image_paths {
    let image_file = load_file(image_path).await?;
    images.push(parse_image(image_file)?);
}
loop {
    render_frame(&amp;images);
}
</code></pre>

<p>We can still make use of the combinators in a more functional-programming style if we wish, but now it&rsquo;s much clearer:</p>

<pre><code class="language-rust">render_loading();
let contents = load_file(&quot;my_manifest_path&quot;).await;
let image_futures = parse_file_contents(contents)
    .map(load_file);
let images: Vec&lt;Image&gt; = try_join_all(image_futures)
    .await?
    .map(parse_image)
    .collect()?;
loop {
    render_frame(&amp;images);
}
</code></pre>

<p><code>platter</code> is small and can be plugged into your own game framework or game project if you want to harness <code>async/await</code> to load files on desktop and web. It will be a major part of the new Quicksilver application lifecyle!</p>

<p>That&rsquo;s Day 2 down, but there are 6 more days of Quicksilver Chanukah:</p>

<ol>
<li><a href="../quicksilver-chanukah-2019">Yesterday&rsquo;s introduction post</a></li>
<li>This post!</li>
<li><a href="../quicksilver-chanukah-2019-day-3"><code>gestalt</code>: An API to manage bundling and saving data locally on desktop and web</a></li>
<li><a href="../quicksilver-chanukah-2019-day-4"><code>blinds</code>: An easy-to-use async wrapper of <code>winit</code></a></li>
<li><code>golem</code>: An opinionated mostly-safe graphics library for desktop and web GL</li>
<li>Changes to the Quicksilver application lifecycle</li>
<li>Changes to the Quicskilver graphics API</li>
<li>An overview of the work on web support this yea5</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>A Quicksilver Chanukah: Day 1</title>
            <link>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019/</link>
            <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://www.ryanisaacg.com/posts/quicksilver-chanukah-2019/</guid>
            <description>I started this year with a blog post about the state of Quicksilver where I set a goal for myself: get web support for important game development crates upstreamed. At the end of the year, I&amp;rsquo;m happy to update this work (by me and many others!) has been a success, and the core of Rust&amp;rsquo;s game ecosystem is now-web enabled. In the future, I want to write a brief overview of those changes, but for now I want to focus on their relevance to Quicksilver.</description>
            <content type="html"><![CDATA[<p>I started this year with a <a href="../state-of-quicksilver-feb-2019">blog post about the state of Quicksilver</a> where I set a goal for myself: get web support for important game development crates upstreamed. At the end of the year, I&rsquo;m happy to update this work (by me and many others!) has been a success, and the core of Rust&rsquo;s game ecosystem is now-web enabled. In the future, I want to write a brief overview of those changes, but for now I want to focus on their relevance to Quicksilver.</p>

<p>Without having to maintain my own set of web bindings for Quicksilver, I was able to start working on significant changes to both the internal and external structure. There are a few entirely unrelated modules in Quicksilver that are all needed for the framework: handling filesystem resources, creating and loading local data, the event loop, the graphics API, and the sound API. It makes sense to allow users to pick and choose these systems, which is the goal of Quicksilver&rsquo;s optional features. However, that still requires depending on Quicksilver, which doesn&rsquo;t make sense for some projects. Instead, I&rsquo;ve created a few new crates that anyone can drop into their project without pulling in any other Quicksilver-related code.</p>

<p>Additionally, a major new Rust feature landed this year: async/await. Quicksilver&rsquo;s asset loading system has been a sticking point, because of its design decisions and the inherent pain of combinator-based <code>Future</code> code. With <code>async</code> and <code>.await</code>, a new asynchronous asset loading API can be almost seamless. Combined with fixes to long-standing graphics API problems, I&rsquo;ve been working on a new major release for Quicksilver (which will be the first breaking change in over a year.)</p>

<p>As <a href="https://en.wikipedia.org/wiki/Hanukkah">Chanukah</a> starts tonight, I&rsquo;m going to share these new crates and big Quicksilver updates over the next eight days. I can&rsquo;t promise I&rsquo;ll actually stick to this schedule, but my goal is:</p>

<ol>
<li>This post!</li>
<li><a href="../quicksilver-chanukah-2019-day-2"><code>platter</code>: An async file-loading API for desktop and web</a></li>
<li><a href="../quicksilver-chanukah-2019-day-3"><code>gestalt</code>: An API to manage bundling and saving data locally on desktop and web</a></li>
<li><a href="../quicksilver-chanukah-2019-day-4"><code>blinds</code>: An easy-to-use async wrapper of <code>winit</code></a></li>
<li><code>golem</code>: An opinionated mostly-safe graphics library for desktop and web GL</li>
<li>Changes to the Quicksilver application lifecycle</li>
<li>Changes to the Quicskilver graphics API</li>
<li>An overview of the work on web support this year</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>Website Makeover</title>
            <link>https://www.ryanisaacg.com/posts/new-blog-debut/</link>
            <pubDate>Sat, 20 Jul 2019 00:00:00 +0000</pubDate>
            
            <guid>https://www.ryanisaacg.com/posts/new-blog-debut/</guid>
            <description>So www.ryanisaacg.com has a very new look, powered by Hugo and my (fairly small) fork of the hello-friend-ng theme. Partly the site will be dedicated to a bit of a professional showcase / bio for myself, but also with added blog functionality I can communicate in a more public way about my plans for my open source projects.
The State of Quicksilver that I wrote earlier this year has moved from its previous home as Github gist to retroactively being a post here, as I feel more comfortable linking to my writing in a domain that I control and can ensure the links stay live.</description>
            <content type="html"><![CDATA[<p>So www.ryanisaacg.com has a very new look, powered by Hugo and my (fairly small) fork of the <a href="https://github.com/rhazdon/hugo-theme-hello-friend-ng">hello-friend-ng</a> theme. Partly the site will be dedicated to a bit of a professional showcase / bio for myself, but also with added blog functionality I can communicate in a more public way about my plans for my open source projects.</p>

<p>The State of Quicksilver that I wrote earlier this year has moved from its previous home as Github gist to retroactively being a post here, as I feel more comfortable linking to my writing in a domain that I control and can ensure the links stay live. The Quicksilver website itself is still hosted within the Quicksilver repo, partially for ease of version control (if a commit changes code, it can change the website docs in lockstep) and partially because I&rsquo;m not sure how much I want to present Quicksilver as being <em>my project</em> versus the <em>Quicksilver project</em>. I&rsquo;m too cheap and lazy to buy a quicksilver domain, so the URL still contains my screen name, but the website is independent of the rest of ryanisaacg.com. Future State-Of-Quicksilver posts will also live on this blog though, as my personal plans for the project and my work for the Rust ecosystem feel out-of-band for the actual Quicksilver site.</p>

<p>I won&rsquo;t be embedding Disqus for comments, but if you want to chat I&rsquo;m on the <a href="https://bit.ly/rust-community">Rust Community Discord</a> as @ryanisaacg. I&rsquo;d love to hear people&rsquo;s thoughts on the new look, if Quicksilver should be moved to a sub-page of this site, and if State of Quicksilver should be a gist, blog posts here, or some combination.</p>
]]></content>
        </item>
        
        <item>
            <title>The State of Quicksilver Feb 2019</title>
            <link>https://www.ryanisaacg.com/posts/state-of-quicksilver-feb-2019/</link>
            <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
            
            <guid>https://www.ryanisaacg.com/posts/state-of-quicksilver-feb-2019/</guid>
            <description>What is Quicksilver? For anyone who doesn&amp;rsquo;t know, Quicksilver is my 2D game framework that targets desktop and web. It is a pure-Rust library that focuses on ergonomics and simplicity.
The State of Rust (WASM) Game Development Quicksilver is part of a small (but growing) set of Rust game engines. Notable are the Amethyst project, an open-source game engine, and ggez, a LOVE-inspired 2D game framework. Increasingly it is practical to build an entire game with only the Rust toolchain: winit provides windowing, a variety of crates allow access to platform graphics APIs, rodio provides sound, rusttype for font rendering, etc.</description>
            <content type="html"><![CDATA[

<h2 id="what-is-quicksilver">What is Quicksilver?</h2>

<p>For anyone who doesn&rsquo;t know, <a href="https://github.com/ryanisaacg/quicksilver">Quicksilver</a> is my 2D game framework that targets desktop and web. It is a pure-Rust library that focuses on ergonomics and simplicity.</p>

<h2 id="the-state-of-rust-wasm-game-development">The State of Rust (WASM) Game Development</h2>

<p>Quicksilver is part of a small (but growing) set of Rust game engines. Notable are the Amethyst project, an open-source game engine, and ggez, a LOVE-inspired 2D game framework.
Increasingly it is practical to build an entire game with only the Rust toolchain: winit provides windowing, a variety of crates allow access to platform graphics APIs, rodio provides sound, rusttype for font rendering, etc. A pure-Rust game framework is getting easier to make all the time.</p>

<p>However, very few libraries support WASM out of the box. This means Quicksilver and Rust WASM games in general essentially have small implementations of windowing, event handling, sounds, graphics, and input for the web that have not been contributed upstream.</p>

<h2 id="the-framework-problem">The Framework Problem</h2>

<p>Opting to use Quicksilver for some feature (web support, API design, automatic batching) requires opting into <em>all</em> of Quicksilver&rsquo;s features. This isn&rsquo;t necessarily great! Even with compile-time feature flags available, it&rsquo;s hard to do any Quicksilver code without buying into the State trait. This boils down to the vision of Quicksilver as a framework: if you can just plug in Quicksilver and start making a game right away, it needs to be everything to everyone.</p>

<p>Partly this is due to Quicksilver&rsquo;s history as a bit of a learning project for me, which I wanted to build from scratch in as many places as possible. It&rsquo;s also caused by my impatience: the Rust ecosystem is amazing and featureful, but waiting for every single upstream project to accept changes would mean that Quicksilver could only be developed as fast as its slowest dependency. I tend to have time to work on the project in bursts, when I clear out the bug backlog and implement a few features from the roadmap; this doesn&rsquo;t mesh well with long-running interactions with other projects. The way I&rsquo;ve handled this in the past is writing my own Javascript bindings for each feature, essentially cloning an entire crate.</p>

<h2 id="the-fundamentals">The Fundamentals</h2>

<p>Largely, Quicksilver&rsquo;s API is approaching a state of stability. It accomplishes most of what I want it to, in a way I&rsquo;m largely satisfied with. For end users, the Quicksilver project has been more or less stable for a few months, and no substantial breaking changes are planned for the future.</p>

<p>However, Quicksilver still has quite a few systems implemented by a dependency and an ad-hoc web clone of that dependency. This is what I hope to change, by contributing web backends across the ecosystem. My ideal outcome is that the fundamental multimedia crates (winit, rodio, gilrs, etc.) can run on WASM out-of-the-box.</p>

<h2 id="going-forward">Going Forward</h2>

<p>If it sounds like my current goal is to make Quicksilver obsolete, that wouldn&rsquo;t be too far off. Quicksilver&rsquo;s raison d&rsquo;etre is packaging up a bundle of functionality and to provide a single API for both web and native. Moving the ecosystem to support web and native makes this less important. Parts of Quicksilver that I think are particularly useful will probably become their own crates (re-exported in Quicksilver) to allow their use outside the framework. Some future version of Quicksilver may just be entirely a re-export of various crates and types with a consistent organization.</p>

<p>In essence, I want seamless desktop and WASM development to move from a selling point of developing games in Quicksilver to a selling point of developing games in Rust.</p>
]]></content>
        </item>
        
    </channel>
</rss>
